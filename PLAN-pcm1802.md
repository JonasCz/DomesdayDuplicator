# Audio ADC Integration Plan for Domesday Duplicator

## Executive Summary

This document outlines the plan to integrate a PCM1802 stereo audio ADC into the Domesday Duplicator to capture two additional audio channels alongside the existing RF signal. The audio data will be sampled at 39.0625 kHz, packed into the existing 16-bit data stream using the top 6 bits, and synchronized with the RF data at exact 1024-sample boundaries that align with the 65536-sample sequence number blocks.

---

## Table of Contents

1. [Current System Architecture](#current-system-architecture)
2. [Proposed Audio Integration Architecture](#proposed-audio-integration-architecture)
3. [Implementation Plan](#implementation-plan)
4. [Testing Strategy](#testing-strategy)
5. [References](#references)

---

## Current System Architecture

### Overview

The Domesday Duplicator captures RF signals from LaserDisc players using:
- **ADC**: Texas Instruments ADS825 (10-bit, 40 MSPS)
- **FPGA**: Terasic DE0-Nano (Altera Cyclone IV EP4CE22F17C6N)
- **USB Interface**: Cypress FX3 SuperSpeed (USB 3.0)
- **Host Software**: Multi-threaded Linux application (also supports Windows)

### Data Flow

```
RF Signal → ADS825 ADC (10-bit, 40 MHz) → DE0-Nano FPGA → Cypress FX3 → USB 3.0 → Host PC
                                           ↓
                                    Data processing:
                                    - Add sequence numbers
                                    - FIFO buffering
                                    - Clock domain crossing (40 MHz → 60 MHz)
```

### Current Data Format (16-bit per sample)

```
Bits [15:10]: Sequence number (6 bits, range 0-62)
Bits [9:0]:   RF sample data (10-bit unsigned from ADC)
```

**Sequence number behavior**:
- Increments every 65536 samples
- Counts from 0 to 62, then wraps to 0
- Same value for all 65536 samples in a block
- Total cycle: 63 × 65536 = 4,128,768 samples before wraparound

### Key Source Files

#### FPGA (Verilog) - Located in `/DE0-NANO/DomesdayDuplicator/`

1. **`DomesdayDuplicator.v`** (lines 27-291)
   - Top-level module
   - Hardware pin mapping for FX3 and ADC
   - GPIO pin assignments:
     - GPIO0[23-33]: Used by ADS825 ADC (10-bit data bus + clock)
     - GPIO1: Used by FX3 interface (16-bit data + control)
     - GPIO0[0-22]: Many pins available for PCM1802 I2S interface
   - PLL instantiation (generates 60 MHz and 40 MHz clocks)
   - Module instantiations

2. **`dataGenerator.v`** (lines 27-84)
   - Reads 10-bit ADC data on each 40 MHz clock edge
   - Adds 6-bit sequence number to top 6 bits
   - Sequence counter: 22-bit register (`sequenceCount[21:16]` = top 6 bits)
   - Increments from 0 to `(63 << 16) - 1`, then wraps
   - Outputs 16-bit words: `{sequenceNumber[5:0], adcData[9:0]}`
   - Also supports test mode (generates incrementing pattern 0-1020)

3. **`buffer.v`** (lines 27-250)
   - Dual-clock FIFO ping-pong buffer
   - Write side: 40 MHz (ADC clock)
   - Read side: 60 MHz (FX3 clock)
   - Buffer size: 8192 16-bit words per buffer (2 buffers total)
   - Matches FX3 USB endpoint size (16 KB)
   - Provides flow control via `dataAvailable` signal

4. **`fx3StateMachine.v`**
   - Mirrors GPIF II state machine
   - Signals FX3 when data is ready for transfer
   - Transfers 8192 words per transaction

5. **`IPpllGenerator.v`**
   - Intel PLL IP core
   - Input: 50 MHz (DE0-Nano onboard clock)
   - Outputs:
     - `c0`: 60 MHz (FX3/FPGA system clock)
     - `c1`: 40 MHz (ADC sampling clock)
   - **Note**: Can add additional outputs for audio clock

#### FX3 Firmware - Located in `/FX3-Firmware/`

1. **`domesdayDuplicator.c`**
   - Main firmware logic
   - GPIF II state machine handles automatic DMA transfers
   - Vendor-specific USB commands:
     - `0xB5`: Start/stop data collection (value 0 or 1)
     - `0xB6`: Configuration bit flags (bit 0 = test mode)
   - Operates in master mode (FX3 provides clock to FPGA)
   - 16 KB buffer size (matches FPGA buffer size)

2. **`domesdayDuplicatorGpif.h`**
   - Generated by GPIF II Designer
   - State machine definition for USB transfers

#### Host Application - Located in `/Linux-Application/DomesdayDuplicator/`

1. **`UsbDeviceBase.h`** (lines 1-239)
   - Base class for USB device communication
   - Multi-threaded architecture:
     - `CaptureThread`: Main coordinator
     - `UsbTransferThread`: Reads data from USB (multiple concurrent transfers)
     - `ProcessingThread`: Validates sequence numbers, writes to disk
   - Key structures:
     - `DiskBufferEntry`: Large buffers for disk writes (multiple USB transfers per disk write)
     - Transfer queue: Multiple in-flight USB transfers for low latency
   - Capture formats supported:
     - `Signed16Bit`: Direct 16-bit samples
     - `Unsigned10Bit`: Packed 10-bit (5 bytes per 4 samples)
     - `Unsigned10Bit4to1Decimation`: Decimated 10-bit

2. **`UsbDeviceBase.cpp`** (lines 831-942)
   - **`ProcessSequenceMarkersAndUpdateSampleMetrics()`**: Critical function for validation
     - Validates sequence number continuity across all samples
     - On startup: Synchronizes with sequence numbers (finds where sequence changes)
     - Checks every sample's sequence number matches expected value
     - Strips sequence number from top 6 bits (sets bits [15:10] to 0)
     - Updates min/max sample statistics
     - **Returns false on ANY sequence mismatch → immediate capture abort**
   - Sequence detection logic (lines 851-886):
     ```cpp
     // Finds first sequence number change within first 65537 samples
     // Calculates sequenceCounter for start of buffer
     // If no sequence numbers detected: disables checking (old firmware compat)
     ```
   - Validation loop (lines 890-913):
     ```cpp
     for (size_t i = 0; i < diskBufferSizeInBytes; i += 2) {
         uint32_t expected = sequenceCounter >> COUNTER_SHIFT;
         uint32_t sequenceNumber = (uint32_t)(diskBuffer[i + 1] >> 2);
         if (sequenceNumber != expected) {
             // ERROR: Sequence mismatch → abort capture
         }
         ++sequenceCounter;
         if (sequenceCounter == (COUNTER_MAX << COUNTER_SHIFT)) {
             sequenceCounter = 0;
         }
     }
     // Strip sequence number: diskBuffer[i + 1] &= 0x03;
     ```

3. **`analysetestdata.cpp`** (lines 252-290)
   - Test data validation for test mode
   - Expects incrementing pattern 0-1020 (or 0-1023 for old firmware)
   - Detects wrap point automatically on first wrap

### USB Transfer Architecture

From documentation and code:

```
┌─────────────────────────────────────────────────────────────────┐
│ USB Transfer Threads (multiple concurrent, ~18 threads total)  │
│  - Each thread: 16 KB transfer from FX3                         │
│  - Callback on completion → store in queue buffer               │
│  - Re-launch transfer for next queue                            │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Disk Buffer Queue (larger than USB queue)                      │
│  - Multiple USB transfers per disk buffer                       │
│  - Marked "ready" when full                                     │
└──────────────────────────────��──────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Disk Write Thread                                               │
│  - Monitors for "ready" buffers                                 │
│  - Validates sequence numbers                                   │
│  - Strips sequence numbers                                      │
│  - Converts format (if needed)                                  │
│  - Writes to disk (large blocks for efficiency)                 │
└─────────────────────────────────────────────────────────────────┘
```

**Performance characteristics**:
- USB bandwidth: 610-916 Mbits/sec (40-60 MSPS × 16 bits)
- Sequence validation: ~5% single-core CPU load
- Multi-core design allows optimal performance on modern CPUs

### Available Hardware Resources

**DE0-Nano FPGA (Cyclone IV EP4CE22F17C6N)**:
- Logic Elements: 22,320
- M9K Memory Blocks: 66 (594 Kbits total)
- PLLs: 4
- GPIO: 2 × 40-pin headers (GPIO0, GPIO1)

**Available GPIO Pins** (from `DomesdayDuplicator.v` lines 116-147):
- GPIO0[0, 1]: Available (adjacent pins, good for I2S)
- GPIO0[8, 9, 10, 11]: Available (for control signals)
- GPIO0[22]: Available (but distant from others)
- GPIO1[0, 1, 7, 9, 11, 13, 15, 17]: Available but used by FX3 interface

**Recommendation**: Use GPIO0[0] (I2S DOUT), GPIO0[1] (I2S LRCK), GPIO0[8] (I2S BCK), GPIO0[9] (SCKI output)

---

## Proposed Audio Integration Architecture

### Goals

1. Add PCM1802 stereo audio ADC for two additional channels
2. Sample at standard audio rate (~40 kHz)
3. Pack audio data into existing 16-bit data stream (top 6 bits)
4. Maintain RF data integrity checking (sequence numbers)
5. Add audio data integrity checking (CRC)
6. Align audio frames with sequence number boundaries for clean processing

### PCM1802 Audio ADC

**Key Specifications**:
- 24-bit stereo ADC
- Sample rates: 16-96 kHz
- System clock: 256fs, 384fs, 512fs, or 768fs
- Master or slave mode
- Output formats: 24-bit I2S, left-justified, or right-justified
- Single-ended analog inputs

**Our Configuration**:
- **Master mode**: PCM1802 generates BCK and LRCK from system clock
- **System clock (SCKI)**: 10 MHz = 256 × 39.0625 kHz
- **Data format**: I2S 24-bit (FMT1=0, FMT0=1)
- **Sample rate**: 39.0625 kHz = 40,000,000 / 1024
- **BCK**: 64 × 39.0625 kHz = 2.5 MHz (generated by PCM1802)
- **LRCK**: 39.0625 kHz (generated by PCM1802)

**I2S Signals**:
- SCKI (input to PCM1802): 10 MHz system clock from FPGA
- BCK (output from PCM1802): 2.5 MHz bit clock
- LRCK (output from PCM1802): 39.0625 kHz word select (L/R)
- DOUT (output from PCM1802): Serial data stream

### Audio Sample Rate Selection: 39.0625 kHz

**Why this specific rate?**

We need the RF samples per audio sample to be a divisor of 65536 (the sequence block size) for perfect alignment.

```
65536 = 2^16

Divisors we can use: 64, 128, 256, 512, 1024, 2048...

RF samples per audio sample = 40,000,000 Hz / audio_rate

Solving for alignment:
- 1024 RF samples per audio → 40,000,000 / 1024 = 39,062.5 Hz ✓
- 512 RF samples per audio → 40,000,000 / 512 = 78,125 Hz (too high)
- 2048 RF samples per audio → 40,000,000 / 2048 = 19,531.25 Hz (too low)

Therefore: 1024 RF samples per audio sample = 39.0625 kHz
```

**Alignment properties**:
```
RF samples per audio sample: 1024
Audio samples per sequence block: 65536 / 1024 = 64
Sequence block time: 65536 / 40,000,000 = 1.6384 ms
Audio sample period: 1024 / 40,000,000 = 25.6 μs
Audio sample rate: 39,062.5 Hz (0.3% difference from 40 kHz)
```

**Result**: Every sequence number boundary (every 65536 samples) perfectly aligns with an audio frame boundary. No audio frame ever spans two different sequence numbers.

### New Data Format

#### Per Audio Frame (1024 RF samples = 1 stereo audio sample)

```
Sample Index    Bits [15:10]           Bits [9:0]
─────────────────────────────────────────────────────────────
0-7             Sync pattern           RF data
                (48-bit total:
                0xDEADBEEFCAFE)

8               Audio_Left[23:18]      RF data
9               Audio_Left[17:12]      RF data
10              Audio_Left[11:6]       RF data
11              Audio_Left[5:0]        RF data

12              Audio_Right[23:18]     RF data
13              Audio_Right[17:12]     RF data
14              Audio_Right[11:6]      RF data
15              Audio_Right[5:0]       RF data

16              CRC[11:6]              RF data
17              CRC[5:0]               RF data

18-1023         Sequence number        RF data
                (same value for all
                1006 samples)
```

**Audio Data**: 48 bits total (24-bit left + 24-bit right) packed into samples 8-15 (8 samples × 6 bits)

**CRC-12**: 12-bit CRC protecting audio data from samples 8-15, stored in samples 16-17

**Overhead**: 18 samples overhead / 1024 samples total = 1.76%

#### Sync Pattern: 0xDEADBEEFCAFE (48-bit)

Spread across samples 0-7 (6 bits per sample):
```
Sample 0: 0b111110 = 0x3E (bits 5:0 of pattern)
Sample 1: 0b111010 = 0x3A (bits 11:6)
Sample 2: 0b101111 = 0x2F (bits 17:12)
Sample 3: 0b111011 = 0x3B (bits 23:18)
Sample 4: 0b101110 = 0x2E (bits 29:24)
Sample 5: 0b111111 = 0x3F (bits 35:30)
Sample 6: 0b101101 = 0x2D (bits 41:36)
Sample 7: 0b110111 = 0x37 (bits 47:42)
```

**Why this pattern?**
- Memorable: DEADBEEF + CAFE
- Easily visible in hex dumps
- Extremely unlikely to occur naturally (2^48 = 281 trillion combinations)
- At 40 MSPS: False positive probability = once every ~2000 hours
- Pattern can be detected with simple 48-bit comparison

#### Audio CRC-12

The CRC-12 protects the audio data integrity. Calculated over samples 8-15 (8 samples = 48 bits of audio data).

**CRC-12 Polynomial**: 0x80F (x^12 + x^11 + x^3 + x^2 + x + 1)

**CRC Calculation**:
```
Input: 8 samples × 6 bits per sample = 48 bits total
Output: 12-bit CRC

Pseudo-code:
crc = 0x000
for sample in samples[8:15]:
    crc = crc_12_step(crc, sample[15:10])
return crc
```

**Note**: Audio CRC does NOT include RF data (bits [9:0]). Only protects audio bits [15:10] from samples 8-15.

**Why CRC-12 instead of CRC-6?**
- Stronger error detection for 48 bits of audio data
- Uses 2 samples (12 bits) for better coverage
- CRC-12 can detect all burst errors ≤12 bits
- Lower false positive rate: 1 in 4096 vs 1 in 64

#### Sequence Number Behavior

```
Samples 0-65535:      Sequence Number = 0 (64 audio frames)
Samples 65536-131071:  Sequence Number = 1 (64 audio frames)
...
Samples 4063232-4128767: Sequence Number = 62 (64 audio frames)
Samples 4128768-...      Sequence Number = 0 (wraparound)
```

**Key property**: Sequence number changes between audio frames (at multiples of 1024), never during a frame.

### FPGA Clock Generation

Modified PLL configuration:

```verilog
IPpllGenerator IPpllGenerator0 (
    .inclk0(CLOCK_50),              // 50 MHz input (DE0-Nano onboard)

    .c0(fx3_clock),                 // 60 MHz (existing, for FX3)
    .c1(adc_clock),                 // 40 MHz (existing, for ADS825)
    .c2(audio_scki)                 // 10 MHz (NEW, for PCM1802)
);
```

**PLL Settings**:
- Input: 50 MHz
- c0: 50 × (6/5) = 60 MHz
- c1: 50 × (4/5) = 40 MHz
- c2: 50 / 5 = 10 MHz

**PCM1802 Clocking**:
- SCKI: 10 MHz from FPGA (256 × 39.0625 kHz)
- PCM1802 internally divides to 256fs for delta-sigma modulator
- BCK output: 64 × 39.0625 kHz = 2.5 MHz
- LRCK output: 39.0625 kHz
- Audio sample delivered: Every 1024 RF samples (25.6 μs)

### FPGA Data Flow

```
┌──────────────────────────────────────────────────────────────┐
│ Clock Generation (PLL)                                       │
│  50 MHz → 60 MHz (FX3)                                       │
│         → 40 MHz (RF ADC)                                    │
│         → 10 MHz (PCM1802 SCKI)                             │
└──────────────────────────────────────────────────────────────┘
                          ↓
┌──────────────────────────────────────────────────────────────┐
│ PCM1802 Audio ADC (External Hardware)                       │
│  Inputs:  SCKI (10 MHz), Analog L/R                         │
│  Outputs: BCK (2.5 MHz), LRCK (39.0625 kHz), DOUT (serial) │
└──────────────────────────────────────────────────────────────┘
                          ↓
┌──────────────────────────────────────────────────────────────┐
│ audioCapture.v (NEW MODULE - I2S Receiver)                  │
│  Inputs:  clk_40MHz, i2s_bck, i2s_lrck, i2s_dout            │
│  Outputs: audio_left[23:0], audio_right[23:0],              │
│           audio_ready (pulse every 1024 RF clocks)           │
│                                                              │
│  Function:                                                   │
│   - Deserializes I2S data stream (24-bit left, 24-bit right)│
│   - Double-synchronizes BCK and LRCK to 40 MHz domain       │
│   - Detects LRCK edge to identify L/R channels              │
│   - Latches completed stereo pair                           │
│   - Pulses audio_ready when new sample available            │
└──────────────────────────────────────────────────────────────┘
                          ↓
┌──────────────────────────────────────────────────────────────┐
│ audioCrc12.v (NEW MODULE - CRC Calculator)                  │
│  Inputs:  clk, reset, data_in[5:0], data_valid              │
│  Outputs: crc_out[11:0]                                      │
│                                                              │
│  Function:                                                   │
│   - Implements CRC-12 using polynomial 0x80F                │
│   - Calculates CRC over 8 samples (samples 8-15)            │
│   - Resets every 1024 samples                               │
└──────────────────────────────────────────────────────────────┘
                          ↓
┌──────────────────────────────────────────────────────────────┐
│ dataGenerator.v (MODIFIED)                                   │
│                                                              │
│  New inputs:                                                 │
│   - audio_left[23:0], audio_right[23:0], audio_ready        │
│                                                              │
│  New state:                                                  │
│   - sample_in_frame[9:0]      // 0-1023 counter             │
│   - audio_left_latch[23:0]    // Latched audio L            │
│   - audio_right_latch[23:0]   // Latched audio R            │
│   - audio_crc[11:0]           // CRC from audioCrc12 module │
│                                                              │
│  Logic (every clock @ 40 MHz):                              │
│   1. Read ADC data → dataOut[9:0]                           │
│   2. Based on sample_in_frame:                              │
│      - 0-7:   Insert SYNC_PATTERN → dataOut[15:10]         │
│      - 8-15:  Insert audio bits → dataOut[15:10]           │
│      - 16-17: Insert audio_crc → dataOut[15:10]            │
│      - 18-1023: Insert sequence number → dataOut[15:10]    │
│   3. Increment sample_in_frame (0-1023, wraps)             │
│   4. If audio_ready: latch new audio_left/right             │
│   5. Sequence counter increments every 65536 samples        │
└──────────────────────────────────────────────────────────────┘
                          ↓
                [Buffer, FX3 State Machine - UNCHANGED]
                          ↓
              [Cypress FX3 USB Interface - UNCHANGED]
```

### Host Software Changes

#### Main Processing Loop

Modified `UsbDeviceBase::ProcessSequenceMarkersAndUnpackAudio()`:

```cpp
bool ProcessSequenceMarkersAndUnpackAudio(
    size_t diskBufferIndex,
    std::vector<AudioFrame>& audioFrames,
    size_t& processedSampleCount,
    uint16_t& minValue, uint16_t& maxValue,
    size_t& minClippedCount, size_t& maxClippedCount)
{
    uint8_t* diskBuffer = diskBufferEntries[diskBufferIndex].readBuffer.data();
    uint32_t sequenceCounter = savedSequenceCounter;

    // Process buffer in 1024-sample audio frames
    for (size_t frameStart = 0; frameStart < diskBufferSizeInBytes; frameStart += 2048) {
        // Step 1: Validate sync pattern (samples 0-7)
        uint64_t sync = extract_48bit_sync(diskBuffer, frameStart);
        if (sync != AUDIO_SYNC_PATTERN) {
            Log().Error("Audio sync lost at sample {0}", frameStart / 2);
            return false;
        }

        // Step 2: Extract audio data (samples 8-15)
        int32_t audioLeft = extract_24bit_audio(diskBuffer, frameStart, 8);
        int32_t audioRight = extract_24bit_audio(diskBuffer, frameStart, 12);

        // Step 3: Validate audio CRC (samples 16-17)
        uint16_t expectedCrc = extract_12bit(diskBuffer, frameStart, 16);
        uint16_t calculatedCrc = calculate_audio_crc12(diskBuffer, frameStart, 8, 8);
        if (expectedCrc != calculatedCrc) {
            Log().Error("Audio CRC mismatch at sample {0}", frameStart / 2);
            return false;
        }

        // Step 4: Store audio frame
        AudioFrame frame;
        frame.left = audioLeft;
        frame.right = audioRight;
        frame.rfSampleOffset = (frameStart / 2);
        audioFrames.push_back(frame);

        // Step 5: Validate sequence number (samples 18-1023)
        uint32_t expectedSeq = sequenceCounter >> COUNTER_SHIFT;
        for (size_t i = 18; i < 1024; i++) {
            uint32_t actualSeq = extract_6bit(diskBuffer, frameStart, i);
            if (actualSeq != expectedSeq) {
                Log().Error("Sequence mismatch at sample {0}", frameStart / 2 + i);
                return false;
            }
        }

        // Step 6: Update sample metrics (scan all 1024 samples for min/max)
        for (size_t i = 0; i < 1024; i++) {
            uint16_t sample = extract_10bit_rf(diskBuffer, frameStart, i);
            minValue = std::min(minValue, sample);
            maxValue = std::max(maxValue, sample);
            if (sample == 0) minClippedCount++;
            if (sample == 1023) maxClippedCount++;
        }

        // Step 7: Strip audio/CRC/sync from top 6 bits (samples 0-17)
        for (size_t i = 0; i < 18; i++) {
            diskBuffer[frameStart + i * 2 + 1] &= 0x03;
        }

        // Step 8: Increment sequence counter (every 65536 samples = 64 frames)
        sequenceCounter += 1024;
        if (sequenceCounter == (COUNTER_MAX << COUNTER_SHIFT)) {
            sequenceCounter = 0;
        }

        processedSampleCount += 1024;
    }

    savedSequenceCounter = sequenceCounter;
    return true;
}
```

#### Audio File Output

New audio file writer:

```cpp
class AudioFileWriter {
public:
    // Create WAV file header for 39.0625 kHz, 24-bit, stereo
    bool Open(const std::filesystem::path& path);

    // Write audio frames (converts 24-bit to WAV format)
    bool WriteFrames(const std::vector<AudioFrame>& frames);

    // Finalize WAV header with correct size
    bool Close();
};
```

**Output files**:
- `capture.lds` - RF data (10-bit, packed or 16-bit)
- `capture.audio.wav` - Audio data (39.0625 kHz, 24-bit stereo WAV)
- Both files synchronized by sample count

#### Lock-On Strategy

On capture start, host must synchronize with audio frame boundaries:

```cpp
bool FindAudioSync(uint8_t* buffer, size_t bufferSize, size_t& offset) {
    // Search for sync pattern
    for (size_t i = 0; i < std::min(bufferSize, 2048); i += 2) {
        uint64_t pattern = extract_48bit_sync(buffer, i);
        if (pattern == AUDIO_SYNC_PATTERN) {
            // Verify CRC at expected position (+16 samples)
            uint16_t crc = extract_12bit(buffer, i, 16);
            uint16_t calc = calculate_audio_crc12(buffer, i, 8, 8);
            if (crc == calc) {
                offset = i;
                Log().Info("Audio sync locked at offset {0}", i / 2);
                return true;
            }
        }
    }
    return false;
}
```

Once locked, all subsequent frames are at predictable offsets (multiples of 1024 samples).

---

## Implementation Plan

### Phase 1: FPGA Clock and PLL Configuration

**Objective**: Add 10 MHz clock output for PCM1802 system clock.

**Tasks**:
1. Open Quartus Prime project: `/DE0-NANO/DomesdayDuplicator/DomesdayDuplicator.qpf`
2. Open PLL MegaWizard for `IPpllGenerator`
   - Currently generates: c0=60MHz, c1=40MHz from 50MHz input
   - Add new output: c2=10MHz (50MHz / 5)
3. Regenerate PLL IP
4. Update `DomesdayDuplicator.v`:
   ```verilog
   wire audio_scki;  // Add new wire

   IPpllGenerator IPpllGenerator0 (
       .inclk0(CLOCK_50),
       .c0(fx3_clock),     // 60 MHz
       .c1(adc_clock),     // 40 MHz
       .c2(audio_scki)     // 10 MHz - NEW
   );

   // Map to GPIO pin
   assign GPIO0[9] = audio_scki;  // SCKI output to PCM1802
   ```
5. Compile and verify timing analysis passes
6. Program FPGA and verify 10 MHz output on GPIO0[9] with oscilloscope

**Success Criteria**:
- ✅ Project compiles without errors
- ✅ Timing constraints met
- ✅ 10 MHz clock visible on GPIO0[9]

### Phase 2: I2S Audio Capture Module

**Objective**: Create Verilog module to deserialize I2S data from PCM1802.

**Tasks**:

1. **Create `audioCapture.v`**:

```verilog
module audioCapture (
    // System clock and reset
    input wire clk_40MHz,
    input wire nReset,

    // I2S inputs from PCM1802
    input wire i2s_bck,     // Bit clock (2.5 MHz)
    input wire i2s_lrck,    // Left/Right clock (39.0625 kHz)
    input wire i2s_dout,    // Serial data

    // Audio output (to dataGenerator)
    output reg [23:0] audio_left,
    output reg [23:0] audio_right,
    output reg audio_ready
);

// Double-synchronize I2S signals to 40 MHz clock domain
reg [2:0] bck_sync;
reg [2:0] lrck_sync;
reg [2:0] dout_sync;

always @(posedge clk_40MHz, negedge nReset) begin
    if (!nReset) begin
        bck_sync <= 3'b0;
        lrck_sync <= 3'b0;
        dout_sync <= 3'b0;
    end else begin
        bck_sync <= {bck_sync[1:0], i2s_bck};
        lrck_sync <= {lrck_sync[1:0], i2s_lrck};
        dout_sync <= {dout_sync[1:0], i2s_dout};
    end
end

wire bck_edge = bck_sync[2] && !bck_sync[1];  // Rising edge
wire lrck_edge = lrck_sync[2] && !lrck_sync[1];

// I2S state machine
reg [4:0] bit_count;  // 0-23 for 24-bit samples
reg [23:0] shift_reg;
reg capturing_left;

always @(posedge clk_40MHz, negedge nReset) begin
    if (!nReset) begin
        bit_count <= 5'd0;
        shift_reg <= 24'd0;
        audio_left <= 24'd0;
        audio_right <= 24'd0;
        audio_ready <= 1'b0;
        capturing_left <= 1'b1;
    end else begin
        audio_ready <= 1'b0;  // Default

        // Detect channel switch
        if (lrck_edge) begin
            if (capturing_left) begin
                // Just finished left channel
                audio_left <= shift_reg;
                capturing_left <= 1'b0;
            end else begin
                // Just finished right channel
                audio_right <= shift_reg;
                capturing_left <= 1'b1;
                audio_ready <= 1'b1;  // Both channels complete
            end
            bit_count <= 5'd0;
            shift_reg <= 24'd0;
        end

        // Shift in data on BCK edge
        if (bck_edge && bit_count < 24) begin
            shift_reg <= {shift_reg[22:0], dout_sync[2]};
            bit_count <= bit_count + 5'd1;
        end
    end
end

endmodule
```

2. **Test bench for `audioCapture.v`**:
   - Simulate I2S signal with known test pattern
   - Verify correct deserialization of 24-bit samples
   - Verify `audio_ready` pulse timing

3. **Integrate into `DomesdayDuplicator.v`**:
   ```verilog
   // GPIO pin assignments for I2S
   wire i2s_bck  = GPIO0[8];   // From PCM1802
   wire i2s_lrck = GPIO0[1];   // From PCM1802
   wire i2s_dout = GPIO0[0];   // From PCM1802

   // Audio capture module
   wire [23:0] audio_left, audio_right;
   wire audio_ready;

   audioCapture audioCapture0 (
       .clk_40MHz(adc_clock),
       .nReset(fx3_nReset),
       .i2s_bck(i2s_bck),
       .i2s_lrck(i2s_lrck),
       .i2s_dout(i2s_dout),
       .audio_left(audio_left),
       .audio_right(audio_right),
       .audio_ready(audio_ready)
   );
   ```

**Success Criteria**:
- ✅ Simulation shows correct I2S deserialization
- ✅ Module compiles and routes successfully
- ✅ Can capture real PCM1802 data (verify with ILA/SignalTap)

### Phase 3: Audio CRC Calculator Module 

**Objective**: Create CRC-12 calculator for audio data integrity.

**Tasks**:

1. **Create `audioCrc12.v`**:

```verilog
module audioCrc12 (
    input wire clk,
    input wire reset,
    input wire [5:0] data_in,
    input wire data_valid,
    output reg [11:0] crc_out
);

// CRC-12 polynomial: x^12 + x^11 + x^3 + x^2 + x + 1 (0x80F)
parameter CRC_POLY = 12'b100000001111;

always @(posedge clk) begin
    if (reset) begin
        crc_out <= 12'h000;  // Initial value
    end else if (data_valid) begin
        // CRC-12 step calculation
        crc_out <= crc12_step(crc_out, data_in);
    end
end

function [11:0] crc12_step;
    input [11:0] crc;
    input [5:0] data;
    reg [11:0] result;
    integer i;
    begin
        result = crc;
        for (i = 5; i >= 0; i = i - 1) begin
            if (result[11] ^ data[i]) begin
                result = {result[10:0], 1'b0} ^ CRC_POLY;
            end else begin
                result = {result[10:0], 1'b0};
            end
        end
        crc12_step = result;
    end
endfunction

endmodule
```

2. **Test bench**:
   - Verify CRC calculation with known test vectors
   - Compare against software reference implementation

**Success Criteria**:
- ✅ CRC matches software reference implementation
- ✅ Module synthesizes efficiently (<100 LEs)

### Phase 4: Modified Data Generator

**Objective**: Modify `dataGenerator.v` to pack audio data into top 6 bits.

**Tasks**:

1. **Backup original**: `cp dataGenerator.v dataGenerator.v.bak`

2. **Major modifications to `dataGenerator.v`**:

```verilog
module dataGenerator (
    input nReset,
    input clock,
    input [9:0] adc_databus,
    input testModeFlag,

    // NEW: Audio inputs
    input [23:0] audio_left_in,
    input [23:0] audio_right_in,
    input audio_ready,

    // Outputs
    output [15:0] dataOut
);

// Existing RF data register
reg [9:0] adcData;
reg [9:0] testData;

// NEW: Frame position counter (0-1023)
reg [9:0] sample_in_frame;

// NEW: Latched audio data
reg [23:0] audio_left_latch;
reg [23:0] audio_right_latch;

// NEW: Audio CRC state
reg [11:0] audio_crc_accumulator;
reg [11:0] audio_crc_final;

// Sequence counter (existing)
reg [21:0] sequenceCount;

// RF data output (unchanged)
assign dataOut[9:0] = testModeFlag ? testData : adcData;

// Top 6 bits: depends on position in frame
reg [5:0] top_6_bits;
assign dataOut[15:10] = top_6_bits;

// Sync pattern: 0xDEADBEEFCAFE
localparam [47:0] SYNC_PATTERN = 48'hDEADBEEFCAFE;

always @ (posedge clock, negedge nReset) begin
    if (!nReset) begin
        adcData <= 10'd0;
        testData <= 10'd0;
        sequenceCount <= 22'd0;
        sample_in_frame <= 10'd0;
        audio_left_latch <= 24'd0;
        audio_right_latch <= 24'd0;
        audio_crc_accumulator <= 12'h000;
        audio_crc_final <= 12'h000;
        top_6_bits <= 6'd0;
    end else begin
        // Read ADC data
        adcData <= adc_databus;

        // Test mode data generation (unchanged)
        if (testData == 10'd1021 - 1)
            testData <= 10'd0;
        else
            testData <= testData + 10'd1;

        // Latch new audio sample when ready
        if (audio_ready) begin
            audio_left_latch <= audio_left_in;
            audio_right_latch <= audio_right_in;
        end

        // Determine top 6 bits based on position in frame
        case (sample_in_frame)
            // Sync pattern (samples 0-7)
            10'd0: top_6_bits <= SYNC_PATTERN[5:0];
            10'd1: top_6_bits <= SYNC_PATTERN[11:6];
            10'd2: top_6_bits <= SYNC_PATTERN[17:12];
            10'd3: top_6_bits <= SYNC_PATTERN[23:18];
            10'd4: top_6_bits <= SYNC_PATTERN[29:24];
            10'd5: top_6_bits <= SYNC_PATTERN[35:30];
            10'd6: top_6_bits <= SYNC_PATTERN[41:36];
            10'd7: top_6_bits <= SYNC_PATTERN[47:42];

            // Audio left channel (samples 8-11)
            10'd8:  top_6_bits <= audio_left_latch[23:18];
            10'd9:  top_6_bits <= audio_left_latch[17:12];
            10'd10: top_6_bits <= audio_left_latch[11:6];
            10'd11: top_6_bits <= audio_left_latch[5:0];

            // Audio right channel (samples 12-15)
            10'd12: top_6_bits <= audio_right_latch[23:18];
            10'd13: top_6_bits <= audio_right_latch[17:12];
            10'd14: top_6_bits <= audio_right_latch[11:6];
            10'd15: top_6_bits <= audio_right_latch[5:0];

            // Audio CRC-12 (samples 16-17)
            10'd16: top_6_bits <= audio_crc_final[11:6];
            10'd17: top_6_bits <= audio_crc_final[5:0];

            // Sequence number (samples 18-1023)
            default: top_6_bits <= sequenceCount[21:16];
        endcase

        // CRC calculation (accumulate during samples 8-15)
        if (sample_in_frame >= 10'd8 && sample_in_frame <= 10'd15) begin
            audio_crc_accumulator <= crc12_step(audio_crc_accumulator, top_6_bits);
        end else if (sample_in_frame == 10'd15) begin
            audio_crc_final <= audio_crc_accumulator;
        end else if (sample_in_frame == 10'd1023) begin
            audio_crc_accumulator <= 12'h000;  // Reset for next frame
        end

        // Increment frame position
        if (sample_in_frame == 10'd1023) begin
            sample_in_frame <= 10'd0;
        end else begin
            sample_in_frame <= sample_in_frame + 10'd1;
        end

        // Sequence counter (increments every 65536 samples)
        if (sequenceCount == (6'd63 << 16) - 1)
            sequenceCount <= 22'd0;
        else
            sequenceCount <= sequenceCount + 22'd1;
    end
end

// CRC-12 step function (inline)
function [11:0] crc12_step;
    input [11:0] crc;
    input [5:0] data;
    // ... (CRC-12 calculation, polynomial 0x80F)
endfunction

endmodule
```

3. **Note**: The case statement only handles specific sample positions where data changes. The default case handles all sequence number samples (18-1023).

4. **Compile and test**:
   - Verify timing closure
   - Use SignalTap to verify:
     - Sync pattern appears every 1024 samples
     - Audio data insertion
     - Sequence number still increments correctly

**Success Criteria**:
- ✅ FPGA compiles without errors
- ✅ Timing analysis passes
- ✅ SignalTap shows correct data structure

### Phase 5: Hardware Integration

**Objective**: Connect PCM1802 to DE0-Nano FPGA.

**Hardware Setup**:

1. **PCM1802 Module** (breakout board or custom PCB):
   - VDD: 3.3V or 5V (check module specs)
   - GND: Common ground
   - SCKI: GPIO0[9] from FPGA (10 MHz)
   - BCK: GPIO0[8] to FPGA (output from PCM1802)
   - LRCK: GPIO0[1] to FPGA (output from PCM1802)
   - DOUT: GPIO0[0] to FPGA (output from PCM1802)
   - FMT0: Tie to VDD (for I2S format)
   - FMT1: Tie to GND (for I2S format)
   - MODE0, MODE1: Set for master mode (see datasheet)
   - AINL, AINR: Audio inputs (analog)

2. **Signal integrity**:
   - Use short wires (<10 cm) for digital signals
   - Add 10-100 Ω series resistors on BCK, LRCK, DOUT if ringing observed
   - Verify 3.3V logic levels

3. **Initial testing**:
   - Apply known test tone (e.g., 1 kHz sine wave) to analog inputs
   - Use oscilloscope to verify:
     - SCKI: 10 MHz square wave
     - BCK: 2.5 MHz square wave
     - LRCK: ~39 kHz square wave
     - DOUT: Serial data stream

**Success Criteria**:
- ✅ All I2S signals present and correct frequency
- ✅ FPGA can deserialize audio data
- ✅ Test tone visible in captured data

### Phase 6: Host Software - Audio Unpacking

**Objective**: Modify host application to extract and validate audio data.

**Files to modify**:

1. **`UsbDeviceBase.h`** (add structures):

```cpp
struct AudioFrame {
    int32_t left;           // 24-bit signed audio (stored in 32-bit)
    int32_t right;          // 24-bit signed audio
    size_t rfSampleOffset;  // Position in RF sample stream
};

// Add to UsbDeviceBase class:
std::vector<AudioFrame> capturedAudioFrames;
std::mutex audioFramesMutex;
```

2. **`UsbDeviceBase.cpp`** - Major changes:

   a. **Replace `ProcessSequenceMarkersAndUpdateSampleMetrics()`** with:
   ```cpp
   bool ProcessSequenceMarkersAndUnpackAudio(
       size_t diskBufferIndex,
       std::vector<AudioFrame>& audioFrames,
       size_t& processedSampleCount,
       uint16_t& minValue, uint16_t& maxValue,
       size_t& minClippedCount, size_t& maxClippedCount);
   ```

   b. **Add helper functions**:
   ```cpp
   // Extract 48-bit sync pattern from 8 samples
   uint64_t ExtractSyncPattern(uint8_t* buffer, size_t byteOffset);

   // Extract 24-bit audio from 4 samples (24 bits = 4 samples × 6 bits)
   int32_t ExtractAudio24Bit(uint8_t* buffer, size_t byteOffset, size_t sampleOffset);

   // Extract 6-bit value from top 6 bits of one sample
   uint8_t Extract6Bit(uint8_t* buffer, size_t byteOffset, size_t sampleIndex);

   // Extract 12-bit value from top 6 bits of two samples
   uint16_t Extract12Bit(uint8_t* buffer, size_t byteOffset, size_t sampleIndex);

   // Calculate CRC-12 over audio data
   uint16_t CalculateAudioCrc12(uint8_t* buffer, size_t byteOffset, size_t startSample, size_t count);
   ```

   c. **Implement sync pattern detection** (for initial lock-on):
   ```cpp
   bool FindAudioSync(uint8_t* buffer, size_t bufferSizeBytes, size_t& offsetBytes);
   ```

3. **Add audio file writer** - Create new file `AudioFileWriter.cpp/h`:

```cpp
class AudioFileWriter {
public:
    AudioFileWriter();
    ~AudioFileWriter();

    bool Open(const std::filesystem::path& path, uint32_t sampleRate);
    bool WriteFrames(const std::vector<AudioFrame>& frames);
    bool Close();

private:
    std::ofstream file;
    size_t totalFramesWritten;

    struct WavHeader {
        // Standard WAV header structure
        char riff[4];           // "RIFF"
        uint32_t fileSize;      // File size - 8
        char wave[4];           // "WAVE"
        char fmt[4];            // "fmt "
        uint32_t fmtSize;       // 16 for PCM
        uint16_t audioFormat;   // 1 = PCM
        uint16_t numChannels;   // 2 = stereo
        uint32_t sampleRate;    // 39062 or 39063
        uint32_t byteRate;      // sampleRate * numChannels * bitsPerSample/8
        uint16_t blockAlign;    // numChannels * bitsPerSample/8
        uint16_t bitsPerSample; // 24
        char data[4];           // "data"
        uint32_t dataSize;      // Size of audio data
    };

    void WriteWavHeader(uint32_t sampleRate);
    void UpdateWavHeader();
};
```

4. **Integrate into capture flow**:
   - Open `.audio.wav` file alongside `.lds` file
   - In `ProcessingThread()`: collect audio frames during processing
   - Periodically flush audio frames to WAV file
   - Close and finalize WAV header when capture stops

**Success Criteria**:
- ✅ Application compiles
- ✅ Can detect audio sync pattern
- ✅ Validates audio CRC
- ✅ Validates sequence numbers
- ✅ Writes valid WAV file
- ✅ Audio plays back correctly

### Phase 7: Integration Testing

**Objective**: Verify complete system operation.

**Test Scenarios**:

1. **Test Mode (no audio)**:
   - Enable test mode (no actual audio data)
   - Audio sections should contain zeros
   - RF test pattern should still validate
   - Verify host handles gracefully

2. **1 kHz Sine Wave Test**:
   - Apply 1 kHz sine wave to both channels
   - Capture 10 seconds
   - Validate:
     - No sequence errors
     - No audio CRC errors
     - WAV file plays 1 kHz tone
     - Frequency analysis confirms 1 kHz

3. **Stereo Separation Test**:
   - Apply 1 kHz to left, 2 kHz to right
   - Verify channels not swapped
   - Check phase relationship

4. **Long Duration Test**:
   - Capture 5+ minutes
   - Verify:
     - No dropped samples (sequence numbers continuous)
     - No audio CRC errors
     - Audio sync maintained throughout
     - RF data still valid

5. **Stress Test**:
   - Run capture while loading CPU with other tasks
   - Verify system handles temporary bandwidth constraints
   - Check for buffer overflows

6. **Audio Frequency Response**:
   - Sweep 20 Hz - 20 kHz
   - Verify audio captured correctly across spectrum
   - Check for aliasing above Nyquist (19.5 kHz)

**Success Criteria**:
- ✅ All tests pass
- ✅ No data corruption detected
- ✅ Audio quality acceptable
- ✅ RF data quality unchanged

### Phase 8: Documentation and Cleanup

**Objective**: Document changes and prepare for production use.

**Tasks**:

1. Update `README.md` with audio capture capabilities
2. Document PCM1802 hardware setup
3. Create schematic/diagram for PCM1802 connection
4. Update user guide with audio capture instructions
5. Add audio format specification to documentation
6. Create example captures with known test signals
7. Git commit with detailed commit message
8. Tag release (e.g., `v4.0-audio-beta`)

---

## Testing Strategy

### Unit Tests

1. **FPGA Modules**:
   - `audioCapture.v`: ModelSim/Questa simulation with I2S stimulus
   - `audioCrc6.v`: Test bench with known CRC test vectors
   - `dataGenerator.v`: Verify data packing with SignalTap

2. **Host Software**:
   - CRC calculation: Unit test with known vectors
   - Audio extraction: Test with synthetic data buffers
   - Sync detection: Test with offset patterns

### Integration Tests

1. **FPGA + Hardware**:
   - PCM1802 I2S capture with oscilloscope verification
   - SignalTap capture of full data path
   - Verify timing across clock domains

2. **Host + FPGA**:
   - End-to-end capture with test signals
   - Validate data integrity (sequence + audio CRC)
   - Verify file outputs (RF + audio)

### System Tests

1. **Real-world capture**:
   - LaserDisc RF + audio commentary/soundtrack
   - Compare audio with direct line-in recording
   - Verify synchronization with video decode

2. **Performance**:
   - CPU usage monitoring during capture
   - Sustained capture time (hours)
   - Multiple concurrent captures (if supported)

---

## References

### Hardware Datasheets

- **PCM1802**: [Texas Instruments PCM1802 Datasheet](https://www.ti.com/lit/ds/symlink/pcm1802.pdf)
  - See section 7.3.4: I2S Mode Timing
  - See section 7.5: System Clock Requirements
  - See Table 6: Data Format Selection

- **ADS825**: [Texas Instruments ADS825 Datasheet](https://www.ti.com/lit/ds/symlink/ads825.pdf)

- **Cypress FX3**: [EZ-USB FX3 Technical Reference Manual](https://www.infineon.com/dgdl/Infineon-EZ-USB_FX3_Technical_Reference_Manual-UserManual-v01_00-EN.pdf?fileId=8ac78c8c7d0d8da4017d0f94d40b76d1)

- **Cyclone IV**: [Intel Cyclone IV Device Handbook](https://www.intel.com/content/www/us/en/docs/programmable/cyclone-iv/handbook.html)

### I2S Protocol

- [I2S Bus Specification (Philips)](http://www.cs.columbia.edu/~sedwards/classes/2014/4840/I2S-bus-specification.pdf)
- [Understanding I2S Audio Format](https://www.sparkfun.com/datasheets/BreakoutBoards/I2SBUS.pdf)

### Source Code Locations

**FPGA (Verilog)**:
- `/DE0-NANO/DomesdayDuplicator/DomesdayDuplicator.v`
- `/DE0-NANO/DomesdayDuplicator/dataGenerator.v`
- `/DE0-NANO/DomesdayDuplicator/buffer.v`
- `/DE0-NANO/DomesdayDuplicator/fx3StateMachine.v`

**FX3 Firmware**:
- `/FX3-Firmware/domesdayDuplicator/domesdayDuplicator.c`

**Host Application**:
- `/Linux-Application/DomesdayDuplicator/UsbDeviceBase.h`
- `/Linux-Application/DomesdayDuplicator/UsbDeviceBase.cpp`
- `/Linux-Application/DomesdayDuplicator/mainwindow.cpp`

### Tools Required

- **Quartus Prime Lite 18.0** (or newer): FPGA compilation
- **ModelSim/Questa**: FPGA simulation (optional but recommended)
- **Qt Creator 4.7.1+**: Host application development
- **GCC 7.0+**: Compiler (Linux)
- **Oscilloscope**: Hardware debugging (I2S signals)
- **Signal Generator**: Audio testing (function generator or sound card)

### External Resources

- [Domesday Duplicator GitHub](https://github.com/simoninns/DomesdayDuplicator)
- [Domesday86 Project Documentation](https://www.domesday86.com/)
- [ld-decode Wiki](https://github.com/happycube/ld-decode/wiki)

---

## Risk Assessment and Mitigation

### Technical Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| FPGA resource exhaustion | High | Low | Current design uses ~30% resources; audio adds ~5% |
| I2S clock domain crossing issues | High | Medium | Use proper synchronizers; test thoroughly |
| Audio CRC false positives/negatives | Medium | Low | Test with synthetic corrupted data |
| Host CPU overhead too high | Medium | Low | Optimize CRC calculation; use SIMD if needed |
| USB bandwidth insufficient | High | Low | Current bandwidth has ~33% margin (60 vs 40 MSPS) |
| PCM1802 clock jitter | Low | Medium | Use stable PLL; verify clock quality with scope |

### Implementation Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Breaking existing RF capture | High | Medium | Extensive regression testing; keep backup of working version |
| Off-by-one errors in frame alignment | Medium | High | Careful code review; unit tests with known offsets |
| Endianness issues in audio extraction | Medium | Medium | Document byte order; test on both architectures |
| WAV file format errors | Low | Low | Use standard library; validate with audio players |

---

## Success Metrics

### Functional Requirements

- ✅ Capture 39.0625 kHz stereo audio synchronized with 40 MSPS RF
- ✅ Detect and report missing samples (via sequence numbers)
- ✅ Detect and report corrupted audio (via CRC-6)
- ✅ Write separate RF and audio files
- ✅ Audio playback quality equivalent to 40 kHz 24-bit reference

### Quality Requirements

- ✅ Audio SNR: >90 dB (limited by PCM1802, not data path)
- ✅ Audio THD: <0.01% (limited by PCM1802, not data path)
- ✅ RF data quality: Unchanged from current system
- ✅ No false positive sync/CRC errors

---

## Appendix A: Detailed Data Format

### Audio Frame Structure (1024 samples = 2048 bytes)

```
Byte Offset  Sample #  High Byte [15:8]                Low Byte [7:0]
─────────────────────────────────────────────────────────────────────
0-1          0         SeqOrAudio[5:0] : RF[9:8]      RF[7:0]
2-3          1         SeqOrAudio[5:0] : RF[9:8]      RF[7:0]
...
14-15        7         SeqOrAudio[5:0] : RF[9:8]      RF[7:0]

Where SeqOrAudio for samples 0-7 = SYNC_PATTERN bits
               for samples 8-15 = Audio data bits
               for samples 16-17 = Audio CRC-12
               for samples 18-1023 = Sequence number
```

### CRC-12 Calculation Details

**Polynomial**: x^12 + x^11 + x^3 + x^2 + x + 1 (binary: 0b1000000001111, hex: 0x80F)

**Initial value**: 0x000 (all zeros)

**Input**: 8 samples × 6 bits per sample = 48 bits (from samples 8-15)

**Algorithm**:
```python
def crc12_update(crc, data):
    """
    Update CRC-12 with 6-bit data
    crc: current CRC value (12 bits)
    data: input data (6 bits)
    returns: updated CRC (12 bits)
    """
    for bit in range(5, -1, -1):  # Process bits 5..0
        if ((crc >> 11) & 1) ^ ((data >> bit) & 1):
            crc = ((crc << 1) ^ 0x80F) & 0xFFF
        else:
            crc = (crc << 1) & 0xFFF
    return crc

def calculate_audio_crc12(audio_bits):
    """
    Calculate CRC-12 over 8 samples of audio data
    audio_bits: list of 8 6-bit values
    """
    crc = 0x000  # Initial value
    for sample in audio_bits:
        crc = crc12_update(crc, sample & 0x3F)
    return crc
```

### Example Audio Frame (Hex Dump)

```
Offset  +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F  ASCII
───────────────────────────────────────────────────────────────────
0000:   DE 3A FE 2B CA 1F E5 17 55 0A 55 12 55 1A 55 22  .º.+..å.U.U.U.U"
0010:   A2 0A B1 12 C3 1A D4 22 3E 0A 2F 12 00 1A 00 22  ¢.±.Ã.Ô">./..."
0020:   00 0A 00 12 00 1A 00 22 ...                       ......."
...
[Samples 0-7: Sync pattern 0xDEADBEEFCAFE]
[Samples 8-15: Audio data (24-bit L + 24-bit R)]
[Samples 16-17: CRC-12]
[Samples 18-1023: Sequence number in all high bytes]
```

---

## Appendix B: PCM1802 Pin Configuration

### Typical Breakout Board Connections

| PCM1802 Pin | Function | Connect To | Description |
|-------------|----------|------------|-------------|
| VDD | Power | 3.3V or 5V | Check module specs |
| VSS | Ground | GND | Common ground |
| SCKI | System Clock In | GPIO0[9] | 10 MHz from FPGA |
| BCK | Bit Clock Out | GPIO0[8] | 2.5 MHz to FPGA |
| LRCK | L/R Clock Out | GPIO0[1] | 39 kHz to FPGA |
| DOUT | Data Out | GPIO0[0] | Serial data to FPGA |
| FMT0 | Format Bit 0 | VDD | I2S format |
| FMT1 | Format Bit 1 | GND | I2S format |
| MD0 | Mode Bit 0 | See datasheet | Master mode config |
| MD1 | Mode Bit 1 | See datasheet | Master mode config |
| AINL | Analog In Left | Signal | Left channel input |
| AINR | Analog In Right | Signal | Right channel input |

**Note**: Some breakout boards may have different naming conventions. Always check the specific board schematic.

---

*End of Plan Document*
