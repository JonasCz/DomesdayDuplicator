# Audio ADC Integration Plan for Domesday Duplicator

## Executive Summary

This document outlines the plan to integrate the onboard ADC128S022 stereo audio ADC into the Domesday Duplicator to capture two additional audio channels alongside the existing RF signal. The audio data will be sampled at 78.125 kHz per channel (12-bit resolution), packed into the existing 16-bit data stream using the top 6 bits, and synchronized with the RF data at exact 512-sample boundaries that align with the 65536-sample sequence number blocks.

**Key advantages of using the onboard ADC128S022:**
- No additional hardware required (ADC already on DE0-Nano board)
- Sample rate: 78.125 kHz per channel (156.25 ksps total conversion rate)
- Simpler data format: 12-bit audio fits in 2 samples per channel (4 samples total for stereo)
- Overhead: 2.73% (14 samples per 512-sample frame)
- Minimal external circuitry: Can test with just resistors and capacitors
- Direct pin connections: ADC128S022 pins are hardwired on DE0-Nano (not using GPIO headers)

---

## Table of Contents

1. [Current System Architecture](#current-system-architecture)
2. [Proposed Audio Integration Architecture](#proposed-audio-integration-architecture)
3. [Implementation Plan](#implementation-plan)
4. [Testing Strategy](#testing-strategy)
5. [References](#references)

---

## Current System Architecture

### Overview

The Domesday Duplicator captures RF signals from LaserDisc players using:
- **ADC**: Texas Instruments ADS825 (10-bit, 40 MSPS)
- **FPGA**: Terasic DE0-Nano (Altera Cyclone IV EP4CE22F17C6N)
- **USB Interface**: Cypress FX3 SuperSpeed (USB 3.0)
- **Host Software**: Multi-threaded Linux application (also supports Windows)

### Data Flow

```
RF Signal → ADS825 ADC (10-bit, 40 MHz) → DE0-Nano FPGA → Cypress FX3 → USB 3.0 → Host PC
                                           ↓
                                    Data processing:
                                    - Add sequence numbers
                                    - FIFO buffering
                                    - Clock domain crossing (40 MHz → 60 MHz)
```

### Current Data Format (16-bit per sample)

```
Bits [15:10]: Sequence number (6 bits, range 0-62)
Bits [9:0]:   RF sample data (10-bit unsigned from ADC)
```

**Sequence number behavior**:
- Increments every 65536 samples
- Counts from 0 to 62, then wraps to 0
- Same value for all 65536 samples in a block
- Total cycle: 63 × 65536 = 4,128,768 samples before wraparound

### Key Source Files

#### FPGA (Verilog) - Located in `/DE0-NANO/DomesdayDuplicator/`

1. **`DomesdayDuplicator.v`** (lines 27-291)
   - Top-level module
   - Hardware pin mapping for FX3 and ADC
   - GPIO pin assignments:
     - GPIO0[23-33]: Used by ADS825 ADC (10-bit data bus + clock)
     - GPIO1: Used by FX3 interface (16-bit data + control)
     - GPIO0[0-22]: Many pins available for PCM1802 I2S interface
   - PLL instantiation (generates 60 MHz and 40 MHz clocks)
   - Module instantiations

2. **`dataGenerator.v`** (lines 27-84)
   - Reads 10-bit ADC data on each 40 MHz clock edge
   - Adds 6-bit sequence number to top 6 bits
   - Sequence counter: 22-bit register (`sequenceCount[21:16]` = top 6 bits)
   - Increments from 0 to `(63 << 16) - 1`, then wraps
   - Outputs 16-bit words: `{sequenceNumber[5:0], adcData[9:0]}`
   - Also supports test mode (generates incrementing pattern 0-1020)

3. **`buffer.v`** (lines 27-250)
   - Dual-clock FIFO ping-pong buffer
   - Write side: 40 MHz (ADC clock)
   - Read side: 60 MHz (FX3 clock)
   - Buffer size: 8192 16-bit words per buffer (2 buffers total)
   - Matches FX3 USB endpoint size (16 KB)
   - Provides flow control via `dataAvailable` signal

4. **`fx3StateMachine.v`**
   - Mirrors GPIF II state machine
   - Signals FX3 when data is ready for transfer
   - Transfers 8192 words per transaction

5. **`IPpllGenerator.v`**
   - Intel PLL IP core
   - Input: 50 MHz (DE0-Nano onboard clock)
   - Outputs:
     - `c0`: 60 MHz (FX3/FPGA system clock)
     - `c1`: 40 MHz (ADC sampling clock)
   - **Note**: Can add additional outputs for audio clock

#### FX3 Firmware - Located in `/FX3-Firmware/`

1. **`domesdayDuplicator.c`**
   - Main firmware logic
   - GPIF II state machine handles automatic DMA transfers
   - Vendor-specific USB commands:
     - `0xB5`: Start/stop data collection (value 0 or 1)
     - `0xB6`: Configuration bit flags (bit 0 = test mode)
   - Operates in master mode (FX3 provides clock to FPGA)
   - 16 KB buffer size (matches FPGA buffer size)

2. **`domesdayDuplicatorGpif.h`**
   - Generated by GPIF II Designer
   - State machine definition for USB transfers

#### Host Application - Located in `/Linux-Application/DomesdayDuplicator/`

1. **`UsbDeviceBase.h`** (lines 1-239)
   - Base class for USB device communication
   - Multi-threaded architecture:
     - `CaptureThread`: Main coordinator
     - `UsbTransferThread`: Reads data from USB (multiple concurrent transfers)
     - `ProcessingThread`: Validates sequence numbers, writes to disk
   - Key structures:
     - `DiskBufferEntry`: Large buffers for disk writes (multiple USB transfers per disk write)
     - Transfer queue: Multiple in-flight USB transfers for low latency
   - Capture formats supported:
     - `Signed16Bit`: Direct 16-bit samples
     - `Unsigned10Bit`: Packed 10-bit (5 bytes per 4 samples)
     - `Unsigned10Bit4to1Decimation`: Decimated 10-bit

2. **`UsbDeviceBase.cpp`** (lines 831-942)
   - **`ProcessSequenceMarkersAndUpdateSampleMetrics()`**: Critical function for validation
     - Validates sequence number continuity across all samples
     - On startup: Synchronizes with sequence numbers (finds where sequence changes)
     - Checks every sample's sequence number matches expected value
     - Strips sequence number from top 6 bits (sets bits [15:10] to 0)
     - Updates min/max sample statistics
     - **Returns false on ANY sequence mismatch → immediate capture abort**
   - Sequence detection logic (lines 851-886):
     ```cpp
     // Finds first sequence number change within first 65537 samples
     // Calculates sequenceCounter for start of buffer
     // If no sequence numbers detected: disables checking (old firmware compat)
     ```
   - Validation loop (lines 890-913):
     ```cpp
     for (size_t i = 0; i < diskBufferSizeInBytes; i += 2) {
         uint32_t expected = sequenceCounter >> COUNTER_SHIFT;
         uint32_t sequenceNumber = (uint32_t)(diskBuffer[i + 1] >> 2);
         if (sequenceNumber != expected) {
             // ERROR: Sequence mismatch → abort capture
         }
         ++sequenceCounter;
         if (sequenceCounter == (COUNTER_MAX << COUNTER_SHIFT)) {
             sequenceCounter = 0;
         }
     }
     // Strip sequence number: diskBuffer[i + 1] &= 0x03;
     ```

3. **`analysetestdata.cpp`** (lines 252-290)
   - Test data validation for test mode
   - Expects incrementing pattern 0-1020 (or 0-1023 for old firmware)
   - Detects wrap point automatically on first wrap

### USB Transfer Architecture

From documentation and code:

```
┌─────────────────────────────────────────────────────────────────┐
│ USB Transfer Threads (multiple concurrent, ~18 threads total)  │
│  - Each thread: 16 KB transfer from FX3                         │
│  - Callback on completion → store in queue buffer               │
│  - Re-launch transfer for next queue                            │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Disk Buffer Queue (larger than USB queue)                      │
│  - Multiple USB transfers per disk buffer                       │
│  - Marked "ready" when full                                     │
└──────────────────────────────��──────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Disk Write Thread                                               │
│  - Monitors for "ready" buffers                                 │
│  - Validates sequence numbers                                   │
│  - Strips sequence numbers                                      │
│  - Converts format (if needed)                                  │
│  - Writes to disk (large blocks for efficiency)                 │
└─────────────────────────────────────────────────────────────────┘
```

**Performance characteristics**:
- USB bandwidth: 610-916 Mbits/sec (40-60 MSPS × 16 bits)
- Sequence validation: ~5% single-core CPU load
- Multi-core design allows optimal performance on modern CPUs

### Available Hardware Resources

**DE0-Nano FPGA (Cyclone IV EP4CE22F17C6N)**:
- Logic Elements: 22,320
- M9K Memory Blocks: 66 (594 Kbits total)
- PLLs: 4
- GPIO: 2 × 40-pin headers (GPIO0, GPIO1)

**Available GPIO Pins** (from `DomesdayDuplicator.v` lines 116-147):
- GPIO0[0, 1]: Available (adjacent pins, good for I2S)
- GPIO0[8, 9, 10, 11]: Available (for control signals)
- GPIO0[22]: Available (but distant from others)
- GPIO1[0, 1, 7, 9, 11, 13, 15, 17]: Available but used by FX3 interface

**Recommendation**: Use GPIO0[0] (I2S DOUT), GPIO0[1] (I2S LRCK), GPIO0[8] (I2S BCK), GPIO0[9] (SCKI output)

---

## Proposed Audio Integration Architecture

### Goals

1. Use onboard ADC128S022 stereo audio ADC for two additional channels
2. Sample at 78.125 kHz per channel (156.25 ksps total conversion rate)
3. Pack audio data into existing 16-bit data stream (top 6 bits)
4. Maintain RF data integrity checking (sequence numbers)
5. Add audio data integrity checking (CRC-12)
6. Align audio frames with sequence number boundaries for clean processing

### ADC128S022 Audio ADC

**Key Specifications**:
- 12-bit, 8-channel SAR ADC
- Conversion rate: 50-200 ksps (total throughput)
- SPI interface with 16 SCLK cycles per conversion
- Supply voltage: 2.7-5.25V (operating at 3.3V on DE0-Nano)
- Analog inputs: 0V to VA (0V to 3.3V in our case)
- Already integrated on DE0-Nano board

**Our Configuration**:
- **Channels used**: Channel 0 (Left), Channel 1 (Right)
- **Per-channel sample rate**: 78.125 kHz
- **Total conversion rate**: 156.25 ksps (well within 50-200 ksps spec)
- **Data format**: 12-bit unsigned (requires DC biasing at 1.65V)
- **SPI clock (SCLK)**: 2.5 MHz (generated by FPGA from 40 MHz)
- **Conversion time**: 16 SCLK cycles = 6.4 µs per sample

**SPI Signals** (directly connected on DE0-Nano, not GPIO):
- ADC_CS_N (Pin A10): Chip select, active low
- ADC_SCLK (Pin B14): Serial clock, 2.5 MHz
- ADC_SADDR (Pin B10): Data TO ADC (DIN) - channel select
- ADC_SDAT (Pin A9): Data FROM ADC (DOUT) - conversion result

**Analog Inputs** (on JP3 header):
- Analog_In0: Left channel (CH0)
- Analog_In1: Right channel (CH1)

### Analog Input Circuitry (Minimal R+C Solution)

The ADC128S022 requires unipolar 0-3.3V input, but line-level audio is bipolar AC. The minimal external circuitry needed consists of resistors and capacitors only:

#### Circuit Per Channel:

```
Line Audio Input ──┬── 10µF ──┬── 10kΩ ──┬─── To ADC_IN (JP3)
(±1V AC)           │   (AC    │          │
                   │  couple) │          │
                  GND         └── 10kΩ ──┤
                                   ↓     │
                                 3.3V   GND (1nF onboard)
                                (bias)
```

**Component List (Per Channel - 2 channels for stereo):**

| Component | Value | Purpose | Notes |
|-----------|-------|---------|-------|
| **C1** | 10µF | Input AC coupling | Electrolytic or ceramic, ≥10V rating |
| **R1** | 10kΩ | Upper bias resistor | 1/4W, 5% tolerance |
| **R2** | 10kΩ | Lower bias resistor | 1/4W, 5% tolerance |
| *Optional:* **C2** | 100nF-220nF | Anti-aliasing filter | Ceramic, for improved noise rejection |

**Total parts for stereo: 2× 10µF caps + 4× 10kΩ resistors**

**Circuit Characteristics:**
- **DC Bias**: 1.65V (mid-scale, ADC reads ~2048 at idle)
- **Input impedance**: ~5kΩ (10kΩ || 10kΩ)
- **High-pass cutoff**: 3.2 Hz (10µF + 5kΩ) - passes full audio spectrum
- **Usable input range**: ±0.825V around 1.65V bias (0.825V to 2.475V)
- **Maximum input**: 1.65Vpp (0.58Vrms) - suitable for consumer line level

**Connections to DE0-Nano JP3 Header:**

| Audio Channel | Components | JP3 Connection |
|---------------|------------|----------------|
| **Left** | 10µF + 2× 10kΩ voltage divider | Pin 23 (Analog_In0) |
| **Right** | 10µF + 2× 10kΩ voltage divider | Pin 25 (Analog_In1) |
| **3.3V supply** | From voltage dividers | Pin 11 (3V3_VCC) |
| **Ground** | Common | Pin 12 (GND) |

**Note**: The DE0-Nano already has 22Ω series resistors and 1nF caps on each ADC input for protection and RF filtering. No additional protection diodes required for testing, but can be added (BAT54S) for robustness.

### Audio Sample Rate Selection: 78.125 kHz

**Why this specific rate?**

We need the RF samples per audio sample to be a divisor of 65536 (the sequence block size) for perfect alignment.

```
65536 = 2^16

Divisors we can use: 64, 128, 256, 512, 1024, 2048...

RF samples per audio sample = 40,000,000 Hz / audio_rate

Solving for alignment:
- 512 RF samples per audio → 40,000,000 / 512 = 78,125 Hz ✓ IMPLEMENTED
- 1024 RF samples per audio → 40,000,000 / 1024 = 39,062.5 Hz (alternate option)
- 256 RF samples per audio → 40,000,000 / 256 = 156,250 Hz (too high for stereo)
- 2048 RF samples per audio → 40,000,000 / 2048 = 19,531.25 Hz (too low)

Therefore: 512 RF samples per audio sample = 78.125 kHz
```

**Alignment properties**:
```
RF samples per audio sample: 512
Audio samples per sequence block: 65536 / 512 = 128 stereo pairs
Sequence block time: 65536 / 40,000,000 = 1.6384 ms
Audio sample period: 512 / 40,000,000 = 12.8 µs
Audio sample rate: 78,125 Hz per channel
Nyquist frequency: 39,062.5 Hz (excellent for full audio spectrum)
```

**Result**: Every sequence number boundary (every 65536 samples) perfectly aligns with an audio frame boundary. No audio frame ever spans two different sequence numbers.

**ADC Conversion Rate**:
- Stereo requires 2 conversions per audio sample (L + R channels)
- Total conversion rate: 78,125 × 2 = 156,250 conversions/sec (156.25 ksps)
- Well within ADC128S022 spec of 50-200 ksps ✓

### New Data Format

#### Per Audio Frame (512 RF samples = 1 stereo audio sample)

```
Sample Index    Bits [15:10]           Bits [9:0]
─────────────────────────────────────────────────────────────
0-7             Sync pattern           RF data
                (48-bit total:
                0xDEADBEEFCAFE)

8               Audio_Left[11:6]       RF data
9               Audio_Left[5:0]        RF data

10              Audio_Right[11:6]      RF data
11              Audio_Right[5:0]       RF data

12              CRC[11:6]              RF data
13              CRC[5:0]               RF data

14-511          Sequence number        RF data
                (same value for all
                498 samples)
```

**Audio Data**: 24 bits total (12-bit left + 12-bit right) packed into samples 8-11 (4 samples × 6 bits)

**CRC-12**: 12-bit CRC protecting audio data from samples 8-11, stored in samples 12-13

**Overhead**: 14 samples overhead / 512 samples total = 2.73%

**Note**: Despite higher percentage overhead, this approach captures at 2× the sample rate (78.125 kHz vs 39.0625 kHz) with simpler unpacking logic.

#### Sync Pattern: 0xDEADBEEFCAFE (48-bit)

Spread across samples 0-7 (6 bits per sample):
```
Sample 0: 0b111110 = 0x3E (bits 5:0 of pattern)
Sample 1: 0b111010 = 0x3A (bits 11:6)
Sample 2: 0b101111 = 0x2F (bits 17:12)
Sample 3: 0b111011 = 0x3B (bits 23:18)
Sample 4: 0b101110 = 0x2E (bits 29:24)
Sample 5: 0b111111 = 0x3F (bits 35:30)
Sample 6: 0b101101 = 0x2D (bits 41:36)
Sample 7: 0b110111 = 0x37 (bits 47:42)
```

**Why this pattern?**
- Memorable: DEADBEEF + CAFE
- Easily visible in hex dumps
- Extremely unlikely to occur naturally (2^48 = 281 trillion combinations)
- At 40 MSPS: False positive probability = once every ~2000 hours
- Pattern can be detected with simple 48-bit comparison

#### Audio CRC-12

The CRC-12 protects the audio data integrity. Calculated over samples 8-15 (8 samples = 48 bits of audio data).

**CRC-12 Polynomial**: 0x80F (x^12 + x^11 + x^3 + x^2 + x + 1)

**CRC Calculation**:
```
Input: 8 samples × 6 bits per sample = 48 bits total
Output: 12-bit CRC

Pseudo-code:
crc = 0x000
for sample in samples[8:15]:
    crc = crc_12_step(crc, sample[15:10])
return crc
```

**Note**: Audio CRC does NOT include RF data (bits [9:0]). Only protects audio bits [15:10] from samples 8-15.

**Why CRC-12 instead of CRC-6?**
- Stronger error detection for 48 bits of audio data
- Uses 2 samples (12 bits) for better coverage
- CRC-12 can detect all burst errors ≤12 bits
- Lower false positive rate: 1 in 4096 vs 1 in 64

#### Sequence Number Behavior

```
Samples 0-65535:      Sequence Number = 0 (128 audio frames)
Samples 65536-131071:  Sequence Number = 1 (128 audio frames)
...
Samples 4063232-4128767: Sequence Number = 62 (128 audio frames)
Samples 4128768-...      Sequence Number = 0 (wraparound)
```

**Key property**: Sequence number changes between audio frames (at multiples of 512), never during a frame.

### FPGA Clock Generation

**No PLL modification needed!** The existing PLL configuration is sufficient:

```verilog
IPpllGenerator IPpllGenerator0 (
    .inclk0(CLOCK_50),              // 50 MHz input (DE0-Nano onboard)

    .c0(fx3_clock),                 // 60 MHz (existing, for FX3)
    .c1(adc_clock)                  // 40 MHz (existing, for ADS825 and ADC128S022 SPI)
);
```

**Clock Derivation**:
- Base clock: 40 MHz (existing, from PLL c1)
- SPI clock generation: 40 MHz ÷ 16 = 2.5 MHz (simple counter/divider in FPGA logic)
- No additional PLL outputs required

**ADC128S022 Clocking**:
- SCLK: 2.5 MHz (generated from 40 MHz via divide-by-16)
- Conversion rate: 2.5 MHz ÷ 16 cycles = 156.25 ksps total (78.125 kHz per channel)
- Audio sample period: 512 RF clocks @ 40 MHz = 12.8 µs
- Each SPI transaction completes in: 16 cycles @ 2.5 MHz = 6.4 µs

### FPGA Data Flow

```
┌──────────────────────────────────────────────────────────────┐
│ Clock Generation (PLL)                                       │
│  50 MHz → 60 MHz (FX3)                                       │
│         → 40 MHz (RF ADC + Audio SPI base clock)            │
└──────────────────────────────────────────────────────────────┘
                          ↓
┌──────────────────────────────────────────────────────────────┐
│ ADC128S022 Audio ADC (Onboard Hardware)                     │
│  Inputs:  CS_N, SCLK (2.5 MHz), DIN (channel select)       │
│  Outputs: DOUT (12-bit conversion result, serial)           │
│  Analog:  Analog_In0 (Left), Analog_In1 (Right) via JP3    │
└──────────────────────────────────────────────────────────────┘
                          ↓
┌──────────────────────────────────────────────────────────────┐
│ adc128spiController.v (NEW MODULE - SPI Master)             │
│  Inputs:  clk_40MHz, reset                                   │
│  Outputs: spi_cs_n, spi_sclk, spi_din, spi_dout (input)    │
│           audio_left[11:0], audio_right[11:0],              │
│           audio_ready (pulse every 512 RF clocks)            │
│                                                              │
│  Function:                                                   │
│   - Generates 2.5 MHz SCLK from 40 MHz (÷16 counter)       │
│   - Alternates between channel 0 and 1 for L/R sampling     │
│   - Sends 3-bit channel address via DIN during first 3 clks │
│   - Reads 12-bit result from DOUT during conversion         │
│   - Latches completed stereo pair every 512 RF samples      │
│   - Pulses audio_ready when new sample available            │
│   - Timing: 16 SCLK cycles × 2 channels = 32 cycles/sample │
└──────────────────────────────────────────────────────────────┘
                          ↓
┌──────────────────────────────────────────────────────────────┐
│ dataGenerator.v (MODIFIED)                                   │
│                                                              │
│  New inputs:                                                 │
│   - audio_left[11:0], audio_right[11:0], audio_ready        │
│                                                              │
│  New state:                                                  │
│   - sample_in_frame[8:0]      // 0-511 counter              │
│   - audio_left_latch[11:0]    // Latched audio L            │
│   - audio_right_latch[11:0]   // Latched audio R            │
│   - top_6_bits[5:0]           // Top 6 bits output          │
│                                                              │
│  Logic (every clock @ 40 MHz):                              │
│   1. Read ADC data → dataOut[9:0]                           │
│   2. Based on sample_in_frame:                              │
│      - 0-7:   Insert SYNC_PATTERN → dataOut[15:10]         │
│      - 8-9:   Insert audio_left bits → dataOut[15:10]      │
│      - 10-11: Insert audio_right bits → dataOut[15:10]     │
│      - 12-13: Insert zeros (CRC placeholder) → [15:10]     │
│      - 14-511: Insert sequence number → dataOut[15:10]     │
│   3. Increment sample_in_frame (0-511, wraps)              │
│   4. If audio_ready: latch new audio_left/right             │
│   5. Sequence counter increments every 65536 samples        │
│                                                              │
│  Note: CRC calculation to be implemented in future update   │
└──────────────────────────────────────────────────────────────┘
                          ↓
                [Buffer, FX3 State Machine - UNCHANGED]
                          ↓
              [Cypress FX3 USB Interface - UNCHANGED]
```

### Host Software Changes

#### Main Processing Loop

Modified `UsbDeviceBase::ProcessSequenceMarkersAndUnpackAudio()`:

```cpp
bool ProcessSequenceMarkersAndUnpackAudio(
    size_t diskBufferIndex,
    std::vector<AudioFrame>& audioFrames,
    size_t& processedSampleCount,
    uint16_t& minValue, uint16_t& maxValue,
    size_t& minClippedCount, size_t& maxClippedCount)
{
    uint8_t* diskBuffer = diskBufferEntries[diskBufferIndex].readBuffer.data();
    uint32_t sequenceCounter = savedSequenceCounter;

    // Process buffer in 512-sample audio frames
    for (size_t frameStart = 0; frameStart < diskBufferSizeInBytes; frameStart += 1024) {
        // Step 1: Validate sync pattern (samples 0-7)
        uint64_t sync = extract_48bit_sync(diskBuffer, frameStart);
        if (sync != AUDIO_SYNC_PATTERN) {
            Log().Error("Audio sync lost at sample {0}", frameStart / 2);
            return false;
        }

        // Step 2: Extract audio data (samples 8-11)
        uint16_t audioLeft = extract_12bit_audio(diskBuffer, frameStart, 8);
        uint16_t audioRight = extract_12bit_audio(diskBuffer, frameStart, 10);
        
        // Convert from unsigned (0-4095) to signed, centered at 2048
        int16_t audioLeftSigned = (int16_t)audioLeft - 2048;
        int16_t audioRightSigned = (int16_t)audioRight - 2048;

        // Step 3: Validate audio CRC (samples 12-13)
        uint16_t expectedCrc = extract_12bit(diskBuffer, frameStart, 12);
        uint16_t calculatedCrc = calculate_audio_crc12(diskBuffer, frameStart, 8, 4);
        if (expectedCrc != calculatedCrc) {
            Log().Error("Audio CRC mismatch at sample {0}", frameStart / 2);
            return false;
        }

        // Step 4: Store audio frame
        AudioFrame frame;
        frame.left = audioLeftSigned;
        frame.right = audioRightSigned;
        frame.rfSampleOffset = (frameStart / 2);
        audioFrames.push_back(frame);

        // Step 5: Validate sequence number (samples 14-511)
        uint32_t expectedSeq = sequenceCounter >> COUNTER_SHIFT;
        for (size_t i = 14; i < 512; i++) {
            uint32_t actualSeq = extract_6bit(diskBuffer, frameStart, i);
            if (actualSeq != expectedSeq) {
                Log().Error("Sequence mismatch at sample {0}", frameStart / 2 + i);
                return false;
            }
        }

        // Step 6: Update sample metrics (scan all 512 samples for min/max)
        for (size_t i = 0; i < 512; i++) {
            uint16_t sample = extract_10bit_rf(diskBuffer, frameStart, i);
            minValue = std::min(minValue, sample);
            maxValue = std::max(maxValue, sample);
            if (sample == 0) minClippedCount++;
            if (sample == 1023) maxClippedCount++;
        }

        // Step 7: Strip audio/CRC/sync from top 6 bits (samples 0-13)
        for (size_t i = 0; i < 14; i++) {
            diskBuffer[frameStart + i * 2 + 1] &= 0x03;
        }

        // Step 8: Increment sequence counter (every 65536 samples = 128 frames)
        sequenceCounter += 512;
        if (sequenceCounter == (COUNTER_MAX << COUNTER_SHIFT)) {
            sequenceCounter = 0;
        }

        processedSampleCount += 512;
    }

    savedSequenceCounter = sequenceCounter;
    return true;
}
```

#### Audio File Output

New audio file writer:

```cpp
class AudioFileWriter {
public:
    // Create WAV file header for 78.125 kHz, 12-bit, stereo
    bool Open(const std::filesystem::path& path);

    // Write audio frames (converts 12-bit to 16-bit WAV format)
    bool WriteFrames(const std::vector<AudioFrame>& frames);

    // Finalize WAV header with correct size
    bool Close();
};
```

**Output files**:
- `capture.lds` - RF data (10-bit, packed or 16-bit)
- `capture.audio.wav` - Audio data (78.125 kHz, 12-bit stereo WAV)
- Both files synchronized by sample count (every 512 RF samples = 1 stereo audio sample)

#### Lock-On Strategy

On capture start, host must synchronize with audio frame boundaries:

```cpp
bool FindAudioSync(uint8_t* buffer, size_t bufferSize, size_t& offset) {
    // Search for sync pattern
    for (size_t i = 0; i < std::min(bufferSize, 2048); i += 2) {
        uint64_t pattern = extract_48bit_sync(buffer, i);
        if (pattern == AUDIO_SYNC_PATTERN) {
            // Verify CRC at expected position (+16 samples)
            uint16_t crc = extract_12bit(buffer, i, 16);
            uint16_t calc = calculate_audio_crc12(buffer, i, 8, 8);
            if (crc == calc) {
                offset = i;
                Log().Info("Audio sync locked at offset {0}", i / 2);
                return true;
            }
        }
    }
    return false;
}
```

Once locked, all subsequent frames are at predictable offsets (multiples of 1024 samples).

---

## Implementation Plan

### Current Status

**Completed Phases:**
- ✅ **Phase 2: SPI Audio Controller** - `adc128spiController.v` fully implemented
  - 40 MHz to 2.5 MHz clock divider working
  - SPI state machine controlling ADC128S022
  - Stereo audio capture at 78.125 kHz per channel
  - Direct pin connections to ADC_CS_N, ADC_SCLK, ADC_SADDR, ADC_SDAT

- ✅ **Phase 3: Data Generator Modifications** - `dataGenerator.v` updated
  - 512-sample audio frame structure implemented
  - Sync pattern insertion (0xDEADBEEFCAFE)
  - 12-bit stereo audio packing into top 6 bits
  - Frame counter and audio latching logic
  - CRC slots reserved (placeholder zeros)

**Remaining Phases:**
- Phase 1: Analog Input Circuit Assembly (hardware)
- Phase 4: End-to-End FPGA Testing
- Phase 5: Host Software - Audio Unpacking
- Phase 6: Integration Testing
- Phase 7: Documentation and Cleanup

---

### Phase 1: Analog Input Circuit Assembly

**Objective**: Build minimal R+C analog input circuit for stereo audio.

**Tasks**:
1. **Gather components:**
   - 2× 10µF capacitors (electrolytic or ceramic, ≥10V)
   - 4× 10kΩ resistors (1/4W, 5% tolerance)
   - Breadboard or perfboard
   - Wire for connections

2. **Build circuit for left channel:**
   - Connect audio left input through 10µF cap (observe polarity if electrolytic)
   - Add voltage divider: 10kΩ to 3.3V, 10kΩ to GND
   - Connect divider center tap to JP3 Pin 23 (Analog_In0)

3. **Build circuit for right channel:**
   - Same as left channel
   - Connect to JP3 Pin 25 (Analog_In1)

4. **Power connections:**
   - 3.3V from JP3 Pin 11
   - GND from JP3 Pin 12

5. **Test with multimeter:**
   - Measure DC voltage at ADC inputs (should be ~1.65V with no signal)
   - Apply 1kHz test tone, verify AC signal present

**Success Criteria**:
- ✅ DC bias measures 1.6-1.7V at both ADC inputs
- ✅ AC signal visible with test tone applied
- ✅ No shorts between power rails

### Phase 2: SPI Audio Controller Module

**Objective**: Create Verilog module for SPI interface to ADC128S022.

**Tasks**:

1. **Create `adc128spiController.v`** (essential implementation details):

```verilog
module adc128spiController (
    input wire clk_40MHz,
    input wire nReset,
    
    // SPI interface to ADC128S022
    output reg spi_cs_n,
    output reg spi_sclk,
    output reg spi_din,         // DIN: channel select TO ADC
    input wire spi_dout,        // DOUT: conversion result FROM ADC
    
    // Audio output
    output reg [11:0] audio_left,
    output reg [11:0] audio_right,
    output reg audio_ready      // Pulses every 512 RF clocks
);

// Clock divider: 40 MHz / 16 = 2.5 MHz
reg [3:0] clk_div;
wire sclk_enable = (clk_div == 4'd15);

always @(posedge clk_40MHz, negedge nReset) begin
    if (!nReset)
        clk_div <= 4'd0;
    else
        clk_div <= clk_div + 4'd1;  // Wraps at 16
end

// SPI state machine
reg [4:0] bit_count;
reg [11:0] shift_reg;
reg channel_select;            // 0 = CH0 (left), 1 = CH1 (right)
reg [8:0] sample_counter;      // Counts to 256 (for 512 RF clocks total)
reg spi_active;

always @(posedge clk_40MHz, negedge nReset) begin
    if (!nReset) begin
        // Initialize all outputs
        spi_cs_n <= 1'b1;
        spi_sclk <= 1'b0;
        spi_din <= 1'b0;
        audio_left <= 12'd0;
        audio_right <= 12'd0;
        audio_ready <= 1'b0;
        channel_select <= 1'b0;
        sample_counter <= 9'd0;
        spi_active <= 1'b0;
    end else begin
        audio_ready <= 1'b0;
        sample_counter <= sample_counter + 9'd1;
        
        // Start conversion every 256 clocks
        if (sample_counter == 9'd255 && !spi_active) begin
            spi_cs_n <= 1'b0;
            spi_active <= 1'b1;
            bit_count <= 5'd0;
        end
        
        if (sclk_enable && spi_active) begin
            spi_sclk <= ~spi_sclk;
            
            if (!spi_sclk) begin  // Rising edge - setup data
                // Send 3-bit channel address: 000 for CH0, 001 for CH1
                if (bit_count < 5'd3) begin
                    if (bit_count == 5'd0)
                        spi_din <= 1'b0;  // Address bit 2
                    else if (bit_count == 5'd1)
                        spi_din <= 1'b0;  // Address bit 1
                    else
                        spi_din <= channel_select;  // Address bit 0
                end
            end else begin  // Falling edge - sample data
                if (bit_count >= 5'd4 && bit_count <= 5'd15)
                    shift_reg <= {shift_reg[10:0], spi_dout};
                
                bit_count <= bit_count + 5'd1;
                
                if (bit_count == 5'd15) begin
                    if (channel_select == 1'b0) begin
                        audio_left <= shift_reg;
                        channel_select <= 1'b1;
                        sample_counter <= 9'd0;
                    end else begin
                        audio_right <= shift_reg;
                        channel_select <= 1'b0;
                        audio_ready <= 1'b1;
                        sample_counter <= 9'd0;
                    end
                    spi_cs_n <= 1'b1;
                    spi_active <= 1'b0;
                end
            end
        end
    end
end

endmodule
```

2. **Test bench for `adc128spiController.v`**:
   - Simulate ADC response with known test values
   - Verify SPI timing (16 SCLK cycles per conversion)
   - Verify `audio_ready` pulse every 512 RF clocks

3. **Integrate into `DomesdayDuplicator.v`**:
   ```verilog
   // Top-level module declaration includes ADC128S022 pins
   module DomesdayDuplicator(
       input        CLOCK_50,
       inout [33:0] GPIO0,
       inout [33:0] GPIO1,
       output [7:0] LED,
       
       // ADC128S022 Audio ADC pins (directly connected on DE0-Nano)
       output       ADC_CS_N,
       output       ADC_SCLK,
       output       ADC_SADDR,    // DIN: channel select TO ADC
       input        ADC_SDAT      // DOUT: conversion result FROM ADC
   );
   
   // Audio signals from SPI controller
   wire [11:0] audio_left;
   wire [11:0] audio_right;
   wire audio_ready;
   
   // Wire assignments for SPI controller
   wire adc128_cs_n;
   wire adc128_sclk;
   wire adc128_din;
   
   assign ADC_CS_N = adc128_cs_n;
   assign ADC_SCLK = adc128_sclk;
   assign ADC_SADDR = adc128_din;     // DIN: channel select TO ADC
   // ADC_SDAT is DOUT: conversion result FROM ADC (input)
   
   // Audio SPI controller for ADC128S022
   adc128spiController audioController0 (
       .clk_40MHz(adc_clock),          // 40 MHz clock
       .nReset(fx3_nReset),            // Not reset
       .spi_dout(ADC_SDAT),            // Data from ADC (DOUT)
       
       // SPI outputs
       .spi_cs_n(adc128_cs_n),         // Chip select
       .spi_sclk(adc128_sclk),         // Serial clock (2.5 MHz)
       .spi_din(adc128_din),           // Data to ADC (DIN - channel select)
       
       // Audio outputs
       .audio_left(audio_left),        // 12-bit left channel
       .audio_right(audio_right),      // 12-bit right channel
       .audio_ready(audio_ready)       // Pulse every 512 RF clocks
   );
   ```

**Success Criteria**:
- ✅ Simulation shows correct SPI timing
- ✅ Module compiles and routes successfully
- ✅ Can read real ADC data (verify with SignalTap)

**Implementation Status**: ✅ COMPLETED - `adc128spiController.v` implemented and integrated

### Phase 3: Modified Data Generator

**Objective**: Modify `dataGenerator.v` to pack 12-bit audio data into top 6 bits.

**Tasks**:

1. **Backup original**: `cp dataGenerator.v dataGenerator.v.bak`

2. **Major modifications to `dataGenerator.v`** (essential parts):

```verilog
module dataGenerator (
    input nReset,
    input clock,
    input [9:0] adc_databus,
    input testModeFlag,
    
    // Audio inputs from SPI controller
    input [11:0] audio_left_in,
    input [11:0] audio_right_in,
    input audio_ready,
    
    // Outputs
    output [15:0] dataOut
);

// Existing registers
reg [9:0] adcData;
reg [9:0] testData;
reg [21:0] sequenceCount;

// NEW: Frame position counter (0-511)
reg [8:0] sample_in_frame;

// NEW: Latched audio data
reg [11:0] audio_left_latch;
reg [11:0] audio_right_latch;

// NEW: Top 6 bits control
reg [5:0] top_6_bits;

// Sync pattern: 0xDEADBEEFCAFE
localparam [47:0] SYNC_PATTERN = 48'hDEADBEEFCAFE;

// Output assignments
assign dataOut[15:10] = top_6_bits;
assign dataOut[9:0] = testModeFlag ? testData : adcData;

always @ (posedge clock, negedge nReset) begin
    if (!nReset) begin
        adcData <= 10'd0;
        testData <= 10'd0;
        sequenceCount <= 22'd0;
        sample_in_frame <= 9'd0;
        audio_left_latch <= 12'd0;
        audio_right_latch <= 12'd0;
        top_6_bits <= 6'd0;
    end else begin
        // Read the ADC data
        adcData <= adc_databus;
        
        // Test mode data generation
        if (testData == 10'd1021 - 1)
            testData <= 10'd0;
        else
            testData <= testData + 10'd1;
        
        // Latch new audio sample when ready
        if (audio_ready) begin
            audio_left_latch <= audio_left_in;
            audio_right_latch <= audio_right_in;
        end
        
        // Determine top 6 bits based on position in frame
        case (sample_in_frame)
            // Sync pattern (samples 0-7)
            9'd0: top_6_bits <= SYNC_PATTERN[5:0];
            9'd1: top_6_bits <= SYNC_PATTERN[11:6];
            9'd2: top_6_bits <= SYNC_PATTERN[17:12];
            9'd3: top_6_bits <= SYNC_PATTERN[23:18];
            9'd4: top_6_bits <= SYNC_PATTERN[29:24];
            9'd5: top_6_bits <= SYNC_PATTERN[35:30];
            9'd6: top_6_bits <= SYNC_PATTERN[41:36];
            9'd7: top_6_bits <= SYNC_PATTERN[47:42];
            
            // Audio left channel (samples 8-9)
            9'd8:  top_6_bits <= audio_left_latch[11:6];
            9'd9:  top_6_bits <= audio_left_latch[5:0];
            
            // Audio right channel (samples 10-11)
            9'd10: top_6_bits <= audio_right_latch[11:6];
            9'd11: top_6_bits <= audio_right_latch[5:0];
            
            // CRC-12 (samples 12-13) - placeholder zeros for now
            9'd12: top_6_bits <= 6'd0;
            9'd13: top_6_bits <= 6'd0;
            
            // Sequence number (samples 14-511)
            default: top_6_bits <= sequenceCount[21:16];
        endcase
        
        // Increment frame position
        if (sample_in_frame == 9'd511) begin
            sample_in_frame <= 9'd0;
        end else begin
            sample_in_frame <= sample_in_frame + 9'd1;
        end
        
        // Sequence number generation
        if (sequenceCount == (6'd63 << 16) - 1)
            sequenceCount <= 22'd0;
        else
            sequenceCount <= sequenceCount + 22'd1;
    end
end

endmodule
```

**Note**: CRC-12 calculation is currently placeholder zeros (samples 12-13). This will be implemented in a future update.

3. **Note**: The case statement handles specific sample positions. The default case handles all sequence number samples (14-511).

4. **Compile and test**:
   - Verify timing closure
   - Use SignalTap to verify:
     - Sync pattern appears every 512 samples
     - Audio data insertion (12-bit values)
     - CRC calculation
     - Sequence number still increments correctly

**Success Criteria**:
- ✅ FPGA compiles without errors
- ✅ Timing analysis passes
- ✅ SignalTap shows correct data structure (512-sample frames)

**Implementation Status**: ✅ COMPLETED - `dataGenerator.v` modified with audio frame packing (CRC placeholder)

### Phase 4: End-to-End FPGA Testing

**Objective**: Test complete FPGA implementation with real analog audio input.

**Test Setup**:

1. **Apply test signals:**
   - Connect 1 kHz sine wave (0.5-1Vpp) to left channel input
   - Connect 2 kHz sine wave to right channel (for stereo verification)
   - Use function generator or smartphone/PC audio output

2. **FPGA verification with SignalTap:**
   - Monitor `audio_left` and `audio_right` signals from SPI controller
   - Verify ADC readings around 2048 ± variation matching input amplitude
   - Verify `audio_ready` pulses every 512 RF clocks
   - Monitor `sample_in_frame` counter (0-511)
   - Check sync pattern insertion at samples 0-7
   - Verify audio data at samples 8-11
   - Verify CRC at samples 12-13
   - Verify sequence numbers at samples 14-511

3. **Timing verification:**
   - Measure actual sample rate with logic analyzer or oscilloscope
   - Should see audio updates every 12.8 µs (512 / 40 MHz)

**Success Criteria**:
- ✅ SPI clock running at 2.5 MHz
- ✅ ADC conversions alternating between channel 0 and 1
- ✅ Audio data visible in SignalTap, tracking input signals
- ✅ Sync pattern appears correctly every 512 samples
- ✅ No timing violations in Quartus TimeQuest analysis

### Phase 5: Host Software - Audio Unpacking

**Objective**: Modify host application to extract and validate audio data.

**Files to modify**:

1. **`UsbDeviceBase.h`** (add structures):

```cpp
struct AudioFrame {
    int16_t left;           // 12-bit signed audio (stored in 16-bit, range ±2048)
    int16_t right;          // 12-bit signed audio
    size_t rfSampleOffset;  // Position in RF sample stream
};

// Add to UsbDeviceBase class:
std::vector<AudioFrame> capturedAudioFrames;
std::mutex audioFramesMutex;
```

2. **`UsbDeviceBase.cpp`** - Major changes:

   a. **Replace `ProcessSequenceMarkersAndUpdateSampleMetrics()`** with:
   ```cpp
   bool ProcessSequenceMarkersAndUnpackAudio(
       size_t diskBufferIndex,
       std::vector<AudioFrame>& audioFrames,
       size_t& processedSampleCount,
       uint16_t& minValue, uint16_t& maxValue,
       size_t& minClippedCount, size_t& maxClippedCount);
   ```

   b. **Add helper functions**:
   ```cpp
   // Extract 48-bit sync pattern from 8 samples
   uint64_t ExtractSyncPattern(uint8_t* buffer, size_t byteOffset);

   // Extract 24-bit audio from 4 samples (24 bits = 4 samples × 6 bits)
   int32_t ExtractAudio24Bit(uint8_t* buffer, size_t byteOffset, size_t sampleOffset);

   // Extract 6-bit value from top 6 bits of one sample
   uint8_t Extract6Bit(uint8_t* buffer, size_t byteOffset, size_t sampleIndex);

   // Extract 12-bit value from top 6 bits of two samples
   uint16_t Extract12Bit(uint8_t* buffer, size_t byteOffset, size_t sampleIndex);

   // Calculate CRC-12 over audio data
   uint16_t CalculateAudioCrc12(uint8_t* buffer, size_t byteOffset, size_t startSample, size_t count);
   ```

   c. **Implement sync pattern detection** (for initial lock-on):
   ```cpp
   bool FindAudioSync(uint8_t* buffer, size_t bufferSizeBytes, size_t& offsetBytes);
   ```

3. **Add audio file writer** - Create new file `AudioFileWriter.cpp/h`:

```cpp
class AudioFileWriter {
public:
    AudioFileWriter();
    ~AudioFileWriter();

    bool Open(const std::filesystem::path& path, uint32_t sampleRate);
    bool WriteFrames(const std::vector<AudioFrame>& frames);
    bool Close();

private:
    std::ofstream file;
    size_t totalFramesWritten;

    struct WavHeader {
        // Standard WAV header structure
        char riff[4];           // "RIFF"
        uint32_t fileSize;      // File size - 8
        char wave[4];           // "WAVE"
        char fmt[4];            // "fmt "
        uint32_t fmtSize;       // 16 for PCM
        uint16_t audioFormat;   // 1 = PCM
        uint16_t numChannels;   // 2 = stereo
        uint32_t sampleRate;    // 78125 Hz
        uint32_t byteRate;      // sampleRate * numChannels * bitsPerSample/8
        uint16_t blockAlign;    // numChannels * bitsPerSample/8
        uint16_t bitsPerSample; // 16 (12-bit data in 16-bit samples)
        char data[4];           // "data"
        uint32_t dataSize;      // Size of audio data
    };

    void WriteWavHeader(uint32_t sampleRate);
    void UpdateWavHeader();
};
```

4. **Integrate into capture flow**:
   - Open `.audio.wav` file alongside `.lds` file
   - In `ProcessingThread()`: collect audio frames during processing
   - Periodically flush audio frames to WAV file
   - Close and finalize WAV header when capture stops

**Success Criteria**:
- ✅ Application compiles
- ✅ Can detect audio sync pattern
- ✅ Validates audio CRC
- ✅ Validates sequence numbers
- ✅ Writes valid WAV file
- ✅ Audio plays back correctly

### Phase 6: Integration Testing

**Objective**: Verify complete system operation.

**Test Scenarios**:

1. **Test Mode (no audio)**:
   - Enable test mode (no actual audio data)
   - Audio sections should contain zeros
   - RF test pattern should still validate
   - Verify host handles gracefully

2. **1 kHz Sine Wave Test**:
   - Apply 1 kHz sine wave to both channels
   - Capture 10 seconds
   - Validate:
     - No sequence errors
     - No audio CRC errors
     - WAV file plays 1 kHz tone
     - Frequency analysis confirms 1 kHz

3. **Stereo Separation Test**:
   - Apply 1 kHz to left, 2 kHz to right
   - Verify channels not swapped
   - Check phase relationship

4. **Long Duration Test**:
   - Capture 5+ minutes
   - Verify:
     - No dropped samples (sequence numbers continuous)
     - No audio CRC errors
     - Audio sync maintained throughout
     - RF data still valid

5. **Stress Test**:
   - Run capture while loading CPU with other tasks
   - Verify system handles temporary bandwidth constraints
   - Check for buffer overflows

6. **Audio Frequency Response**:
   - Sweep 20 Hz - 20 kHz
   - Verify audio captured correctly across spectrum
   - Check for aliasing above Nyquist (19.5 kHz)

**Success Criteria**:
- ✅ All tests pass
- ✅ No data corruption detected
- ✅ Audio quality acceptable
- ✅ RF data quality unchanged

### Phase 7: Documentation and Cleanup

**Objective**: Document changes and prepare for production use.

**Tasks**:

1. Update `README.md` with audio capture capabilities
2. Document ADC128S022 usage and analog input circuit
3. Create schematic/diagram for R+C analog input circuit
4. Document component sourcing (2× 10µF caps, 4× 10kΩ resistors)
5. Update user guide with audio capture instructions
6. Add audio format specification to documentation (78.125 kHz, 12-bit)
7. Create example captures with known test signals
8. Document advantages of onboard ADC approach vs external ADC
9. Git commit with detailed commit message
10. Tag release (e.g., `v4.0-audio-adc128-beta`)

---

## Testing Strategy

### Unit Tests

1. **FPGA Modules**:
   - `adc128spiController.v`: ModelSim/Questa simulation with SPI stimulus
   - `dataGenerator.v`: Verify 12-bit audio packing with SignalTap
   - CRC-12 function: Test bench with known CRC test vectors

2. **Host Software**:
   - CRC calculation: Unit test with known vectors
   - 12-bit audio extraction: Test with synthetic data buffers
   - Sync detection: Test with offset patterns
   - Unsigned to signed conversion: Verify ±2048 range

### Integration Tests

1. **FPGA + Hardware**:
   - ADC128S022 SPI capture with oscilloscope verification
   - SignalTap capture of full data path
   - Verify SPI timing (2.5 MHz SCLK, 16 cycles per conversion)
   - Test analog input circuit with known voltages

2. **Host + FPGA**:
   - End-to-end capture with test audio signals (1 kHz sine wave)
   - Validate data integrity (sequence + audio CRC)
   - Verify file outputs (RF + audio WAV)
   - Verify audio sample rate (78.125 kHz) with frequency analysis

### System Tests

1. **Real-world capture**:
   - LaserDisc RF + audio commentary/soundtrack
   - Compare audio with direct line-in recording
   - Verify synchronization with video decode

2. **Performance**:
   - CPU usage monitoring during capture
   - Sustained capture time (hours)
   - Multiple concurrent captures (if supported)

---

## References

### Hardware Datasheets

- **ADC128S022**: [Texas Instruments ADC128S022 Datasheet](https://www.ti.com/lit/ds/symlink/adc128s022.pdf)
  - See section 7.3.1: Serial Interface
  - See section 6.5: Electrical Characteristics
  - See Table 3: Input Channel Selection

- **ADS825**: [Texas Instruments ADS825 Datasheet](https://www.ti.com/lit/ds/symlink/ads825.pdf)

- **Cypress FX3**: [EZ-USB FX3 Technical Reference Manual](https://www.infineon.com/dgdl/Infineon-EZ-USB_FX3_Technical_Reference_Manual-UserManual-v01_00-EN.pdf?fileId=8ac78c8c7d0d8da4017d0f94d40b76d1)

- **Cyclone IV**: [Intel Cyclone IV Device Handbook](https://www.intel.com/content/www/us/en/docs/programmable/cyclone-iv/handbook.html)

- **DE0-Nano**: [Terasic DE0-Nano User Manual](https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&CategoryNo=165&No=593&PartNo=4)

### SPI Protocol

- [SPI Bus Overview](https://www.analog.com/en/analog-dialogue/articles/introduction-to-spi-interface.html)
- [Understanding SPI Communication](https://www.circuitbasics.com/basics-of-the-spi-communication-protocol/)

### Source Code Locations

**FPGA (Verilog)**:
- `/DE0-NANO/DomesdayDuplicator/DomesdayDuplicator.v`
- `/DE0-NANO/DomesdayDuplicator/dataGenerator.v`
- `/DE0-NANO/DomesdayDuplicator/buffer.v`
- `/DE0-NANO/DomesdayDuplicator/fx3StateMachine.v`

**FX3 Firmware**:
- `/FX3-Firmware/domesdayDuplicator/domesdayDuplicator.c`

**Host Application**:
- `/Linux-Application/DomesdayDuplicator/UsbDeviceBase.h`
- `/Linux-Application/DomesdayDuplicator/UsbDeviceBase.cpp`
- `/Linux-Application/DomesdayDuplicator/mainwindow.cpp`

### Tools Required

- **Quartus Prime Lite 18.0** (or newer): FPGA compilation
- **ModelSim/Questa**: FPGA simulation (optional but recommended)
- **Qt Creator 4.7.1+**: Host application development
- **GCC 7.0+**: Compiler (Linux)
- **Oscilloscope**: Hardware debugging (I2S signals)
- **Signal Generator**: Audio testing (function generator or sound card)

### External Resources

- [Domesday Duplicator GitHub](https://github.com/simoninns/DomesdayDuplicator)
- [Domesday86 Project Documentation](https://www.domesday86.com/)
- [ld-decode Wiki](https://github.com/happycube/ld-decode/wiki)

---

## Risk Assessment and Mitigation

### Technical Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| FPGA resource exhaustion | High | Low | Current design uses ~30% resources; SPI controller adds ~3% |
| SPI timing issues | Medium | Low | Well-defined protocol; 2.5 MHz well within spec |
| Audio CRC false positives/negatives | Medium | Low | Test with synthetic corrupted data |
| Host CPU overhead too high | Medium | Low | Optimize CRC calculation; use SIMD if needed |
| USB bandwidth insufficient | High | Low | Current bandwidth has ~33% margin (60 vs 40 MSPS) |
| Analog input circuit noise | Medium | Medium | Use quality caps; add optional 100nF filter cap |
| DC bias drift | Low | Low | 1% resistor tolerance acceptable; can trim if needed |
| Input overload | Medium | Low | Onboard 22Ω resistor provides some protection |

### Implementation Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Breaking existing RF capture | High | Medium | Extensive regression testing; keep backup of working version |
| Off-by-one errors in frame alignment | Medium | High | Careful code review; unit tests with known offsets |
| Endianness issues in audio extraction | Medium | Medium | Document byte order; test on both architectures |
| WAV file format errors | Low | Low | Use standard library; validate with audio players |

---

## Success Metrics

### Functional Requirements

- ✅ Capture 78.125 kHz stereo audio synchronized with 40 MSPS RF
- ✅ Detect and report missing samples (via sequence numbers)
- ✅ Detect and report corrupted audio (via CRC-12)
- ✅ Write separate RF and audio files
- ✅ Audio playback quality suitable for commentary/monitoring

### Quality Requirements

- ✅ Audio SNR: >70 dB (12-bit ADC, typical 70-73 dB per datasheet)
- ✅ Audio THD: <0.1% (limited by ADC128S022 and analog input circuit)
- ✅ RF data quality: Unchanged from current system
- ✅ No false positive sync/CRC errors
- ✅ Frequency response: 3 Hz - 39 kHz (well within audible spectrum)

---

## Appendix A: Detailed Data Format

### Audio Frame Structure (512 samples = 1024 bytes)

```
Byte Offset  Sample #  High Byte [15:8]                Low Byte [7:0]
─────────────────────────────────────────────────────────────────────
0-1          0         SeqOrAudio[5:0] : RF[9:8]      RF[7:0]
2-3          1         SeqOrAudio[5:0] : RF[9:8]      RF[7:0]
...
14-15        7         SeqOrAudio[5:0] : RF[9:8]      RF[7:0]
16-17        8         Audio_L[11:6]  : RF[9:8]       RF[7:0]
18-19        9         Audio_L[5:0]   : RF[9:8]       RF[7:0]
20-21        10        Audio_R[11:6]  : RF[9:8]       RF[7:0]
22-23        11        Audio_R[5:0]   : RF[9:8]       RF[7:0]
24-25        12        CRC[11:6]      : RF[9:8]       RF[7:0]
26-27        13        CRC[5:0]       : RF[9:8]       RF[7:0]
28-...       14-511    SequenceNum    : RF[9:8]       RF[7:0]

Where SeqOrAudio for samples 0-7   = SYNC_PATTERN bits (48-bit)
               for samples 8-9     = Audio Left (12-bit)
               for samples 10-11   = Audio Right (12-bit)
               for samples 12-13   = Audio CRC-12
               for samples 14-511  = Sequence number
```

### CRC-12 Calculation Details

**Polynomial**: x^12 + x^11 + x^3 + x^2 + x + 1 (binary: 0b1000000001111, hex: 0x80F)

**Initial value**: 0x000 (all zeros)

**Input**: 4 samples × 6 bits per sample = 24 bits (from samples 8-11)

**Algorithm**:
```python
def crc12_update(crc, data):
    """
    Update CRC-12 with 6-bit data
    crc: current CRC value (12 bits)
    data: input data (6 bits)
    returns: updated CRC (12 bits)
    """
    for bit in range(5, -1, -1):  # Process bits 5..0
        if ((crc >> 11) & 1) ^ ((data >> bit) & 1):
            crc = ((crc << 1) ^ 0x80F) & 0xFFF
        else:
            crc = (crc << 1) & 0xFFF
    return crc

def calculate_audio_crc12(audio_bits):
    """
    Calculate CRC-12 over 4 samples of audio data (samples 8-11)
    audio_bits: list of 4 6-bit values
    """
    crc = 0x000  # Initial value
    for sample in audio_bits:
        crc = crc12_update(crc, sample & 0x3F)
    return crc
```

### Example Audio Frame (Hex Dump)

```
Offset  +0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B ++C +D +E +F  ASCII
───────────────────────────────────────────────────────────────────
0000:   FE 3A FA 2B FE 1F FA 17 D2 0A 15 12 C8 1A 23 22  þ:ú+þ.ú.Ò...È.#"
0010:   1A 0A 3B 12 00 1A 00 22 00 0A 00 12 ...          ..;...."....
...
[Samples 0-7: Sync pattern 0xDEADBEEFCAFE]
[Samples 8-9: Audio Left (12-bit, e.g., 0x825 = 2085 decimal)]
[Samples 10-11: Audio Right (12-bit, e.g., 0x78D = 1933 decimal)]
[Samples 12-13: CRC-12]
[Samples 14-511: Sequence number in all high bytes]

Note: This is an idealized example. Actual RF data in lower 10 bits will vary.
```

---

## Appendix B: PCM1802 Pin Configuration

### Typical Breakout Board Connections

| PCM1802 Pin | Function | Connect To | Description |
|-------------|----------|------------|-------------|
| VDD | Power | 3.3V or 5V | Check module specs |
| VSS | Ground | GND | Common ground |
| SCKI | System Clock In | GPIO0[9] | 10 MHz from FPGA |
| BCK | Bit Clock Out | GPIO0[8] | 2.5 MHz to FPGA |
| LRCK | L/R Clock Out | GPIO0[1] | 39 kHz to FPGA |
| DOUT | Data Out | GPIO0[0] | Serial data to FPGA |
| FMT0 | Format Bit 0 | VDD | I2S format |
| FMT1 | Format Bit 1 | GND | I2S format |
| MD0 | Mode Bit 0 | See datasheet | Master mode config |
| MD1 | Mode Bit 1 | See datasheet | Master mode config |
| AINL | Analog In Left | Signal | Left channel input |
| AINR | Analog In Right | Signal | Right channel input |

**Note**: Some breakout boards may have different naming conventions. Always check the specific board schematic.

---

*End of Plan Document*
